syntax = "proto3";

package netfence.v1;

option go_package = "github.com/danthegoodman1/netfence/api/v1;apiv1";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "v1/types.proto";

// DaemonService is the local API exposed by the daemon.
// This runs on a local socket (e.g., unix:///var/run/netfence.sock).
// Use this to attach/detach filters from your orchestration system.
service DaemonService {
  // Attach attaches an eBPF filter and subscribes it to the control plane.
  rpc Attach(AttachRequest) returns (AttachResponse);

  // Detach removes the eBPF filter and unsubscribes from the control plane.
  rpc Detach(DetachRequest) returns (google.protobuf.Empty);

  // List returns attached filters with pagination (sorted by attach time).
  rpc List(ListRequest) returns (ListResponse);

  // GetStatus returns the current daemon status.
  rpc GetStatus(google.protobuf.Empty) returns (DaemonStatus);
}

// AttachRequest specifies what to attach the eBPF filter to.
message AttachRequest {
  oneof target {
    // Network interface name for TC attachment (e.g., "eth0", "veth123")
    string interface_name = 1;
    // Cgroup path for cgroup attachment (e.g., "/sys/fs/cgroup/user.slice/...")
    string cgroup_path = 2;
  }
  // Initial policy mode (defaults to DISABLED if not specified)
  PolicyMode mode = 3;
  // User-defined metadata (VM ID, tenant, container ID, etc.)
  // This is passed to the control plane with the subscription.
  map<string, string> metadata = 4;
}

// AttachResponse confirms attachment.
message AttachResponse {
  // Unique identifier for this attachment (use this for detach)
  string id = 1;
  // DNS server address for this attachment (e.g., "127.0.0.1:5353")
  // Configure the container/VM to use this as its DNS resolver
  string dns_address = 2;
}

// DetachRequest specifies which attachment to remove.
message DetachRequest {
  // Attachment ID (from AttachResponse)
  string id = 1;
}

// ListRequest specifies pagination parameters.
message ListRequest {
  // Maximum number of attachments to return (default: 100, max: 1000)
  int32 page_size = 1;
  // Page token from a previous ListResponse for fetching the next page
  string page_token = 2;
}

// ListResponse contains active attachments with pagination.
message ListResponse {
  repeated AttachmentInfo attachments = 1;
  // Token to retrieve the next page (empty if no more results)
  string next_page_token = 2;
  // Total number of attachments (across all pages)
  int32 total_count = 3;
}

// AttachmentInfo contains details about an active attachment.
message AttachmentInfo {
  string id = 1;
  // The target (interface name or cgroup path)
  string target = 2;
  // Type of attachment
  AttachmentType type = 3;
  // IP filter policy mode
  PolicyMode mode = 4;
  // DNS filtering mode
  DnsMode dns_mode = 5;
  // DNS server address for this attachment
  string dns_address = 6;
  map<string, string> metadata = 7;
  uint64 packets_allowed = 8;
  uint64 packets_blocked = 9;
  uint64 dns_queries_allowed = 10;
  uint64 dns_queries_blocked = 11;
  // When the filter was attached (used for stable pagination ordering)
  google.protobuf.Timestamp attached_at = 12;
}

// DaemonStatus contains the current state of the daemon.
message DaemonStatus {
  string version = 1;
  string daemon_id = 2;
  string hostname = 3;
  // Control plane connection state
  ConnectionState control_plane_state = 4;
  string control_plane_address = 5;
  int32 attachment_count = 6;
}

// ConnectionState represents the control plane connection status.
enum ConnectionState {
  CONNECTION_STATE_UNSPECIFIED = 0;
  CONNECTION_STATE_DISCONNECTED = 1;
  CONNECTION_STATE_CONNECTING = 2;
  CONNECTION_STATE_CONNECTED = 3;
}
