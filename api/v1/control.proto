syntax = "proto3";

package netfence.v1;

option go_package = "github.com/danthegoodman1/netfence/api/v1;apiv1";

import "google/protobuf/duration.proto";
import "v1/types.proto";

// ControlPlane is the service that users implement on their control plane
// server. The daemon connects to this service and maintains a bidirectional
// stream.
service ControlPlane {
  // Connect establishes a bidirectional stream between the daemon and control
  // plane.
  //
  // Flow:
  // 1. Daemon connects and sends SyncRequest with current attachments
  // 2. Control plane sends SyncAck
  // 3. Daemon sends Subscribed when local orchestration attaches filters
  // 4. Control plane sends filter commands (AllowCIDR, SetMode, etc.)
  // 5. Daemon sends Unsubscribed when attachments are detached/removed
  rpc Connect(stream DaemonEvent) returns (stream ControlCommand);
}

// DaemonEvent represents events sent from the daemon to the control plane.
message DaemonEvent {
  oneof event {
    // Initial sync request sent on connect/reconnect
    SyncRequest sync = 1;
    // Notification that a new attachment is now subscribed
    Subscribed subscribed = 2;
    // Notification that an attachment has been unsubscribed
    Unsubscribed unsubscribed = 3;
    // Periodic heartbeat with optional stats
    Heartbeat heartbeat = 4;
  }
}

// SyncRequest is sent when the daemon connects or reconnects.
// It lists all current attachments so the control plane can resync.
message SyncRequest {
  // Daemon instance identifier (stable across restarts)
  string daemon_id = 1;
  // Hostname for identification
  string hostname = 2;
  // All current attachments managed by this daemon
  repeated Attachment attachments = 3;
  // User-defined metadata from daemon config (region, tags, etc.)
  map<string, string> metadata = 4;
}

// Attachment describes a filter attachment managed by the daemon.
message Attachment {
  // Unique identifier for this attachment
  string id = 1;
  // The target (interface name or cgroup path)
  string target = 2;
  // Type of attachment
  AttachmentType type = 3;
  // Current IP filter policy mode
  PolicyMode mode = 4;
  // Current DNS filtering mode
  DnsMode dns_mode = 5;
  // User-defined metadata (VM ID, tenant, etc.)
  map<string, string> metadata = 6;
}

// Subscribed notifies that a new filter attachment is now managed.
message Subscribed {
  // Unique identifier for this attachment
  string id = 1;
  // The target (interface name or cgroup path)
  string target = 2;
  // Type of attachment
  AttachmentType type = 3;
  // Initial IP filter policy mode
  PolicyMode mode = 4;
  // Initial DNS filtering mode
  DnsMode dns_mode = 5;
  // DNS server address for this attachment (e.g., "10.0.0.1:53")
  // Containers should use this as their DNS resolver
  string dns_address = 6;
  // User-defined metadata for associating with VM ID, tenant, etc.
  map<string, string> metadata = 7;
}

// Unsubscribed notifies that an attachment is no longer managed.
message Unsubscribed {
  // The attachment that was removed
  string id = 1;
  // Reason for removal
  UnsubscribeReason reason = 2;
  // Error message if reason is ERROR
  string error = 3;
}

// UnsubscribeReason explains why an attachment was unsubscribed.
enum UnsubscribeReason {
  UNSUBSCRIBE_REASON_UNSPECIFIED = 0;
  // Target no longer exists in the system (interface removed, cgroup gone)
  UNSUBSCRIBE_REASON_REMOVED = 1;
  // Explicit detach request via local API
  UNSUBSCRIBE_REASON_DETACHED = 2;
  // Error maintaining the eBPF attachment
  UNSUBSCRIBE_REASON_ERROR = 3;
}

// Heartbeat is sent periodically to keep the connection alive and report stats.
message Heartbeat { repeated AttachmentStats stats = 1; }

// AttachmentStats reports statistics for a single attachment.
message AttachmentStats {
  string id = 1;
  uint64 packets_allowed = 2;
  uint64 packets_blocked = 3;
  uint64 dns_queries_allowed = 4;
  uint64 dns_queries_blocked = 5;
}

// ControlCommand represents commands sent from the control plane to the daemon.
message ControlCommand {
  // Target attachment ID
  string id = 1;

  oneof command {
    // Acknowledge sync (sent after receiving SyncRequest)
    SyncAck sync_ack = 2;
    // Change the IP filter policy mode
    SetMode set_mode = 3;
    // Add a CIDR to the allowlist
    CIDREntry allow_cidr = 4;
    // Add a CIDR to the denylist
    CIDREntry deny_cidr = 5;
    // Remove a CIDR from allow/deny lists
    string remove_cidr = 6;
    // Bulk update - set complete state for an attachment
    BulkUpdate bulk_update = 7;
    // Change the DNS mode
    SetDnsMode set_dns_mode = 8;
    // Add a domain to the DNS allowlist
    DomainEntry allow_domain = 9;
    // Add a domain to the DNS denylist
    DomainEntry deny_domain = 10;
    // Remove a domain from DNS allow/deny lists
    string remove_domain = 11;
  }
}

// SyncAck acknowledges that the control plane has processed the SyncRequest.
message SyncAck {}

// SetMode changes the policy mode for an attachment.
message SetMode { PolicyMode mode = 1; }

// BulkUpdate sets the complete state for an attachment.
// Clears existing rules and replaces with the provided state.
message BulkUpdate {
  // IP filter policy mode
  PolicyMode mode = 1;
  // CIDRs to allow
  repeated CIDREntry allow_cidrs = 2;
  // CIDRs to deny
  repeated CIDREntry deny_cidrs = 3;
  // DNS configuration
  DnsConfig dns = 4;
}

// DnsConfig contains the complete DNS filtering configuration.
message DnsConfig {
  // DNS filtering mode
  DnsMode mode = 1;
  // Domains to allow (when mode is ALLOWLIST or to override in DENYLIST)
  repeated DomainEntry allow_domains = 2;
  // Domains to deny (when mode is DENYLIST or to override in ALLOWLIST)
  repeated DomainEntry deny_domains = 3;
  // Upstream DNS servers to use for resolution (optional, uses system default
  // if empty)
  repeated string upstream_servers = 4;
}

// CIDREntry represents a CIDR with optional TTL.
message CIDREntry {
  string cidr = 1;
  google.protobuf.Duration ttl = 2;
}

// DomainEntry represents a domain with optional settings.
message DomainEntry {
  // The domain (e.g., "example.com")
  string domain = 1;
  // Whether to include subdomains (e.g., "*.example.com")
  bool include_subdomains = 2;
}

// SetDnsMode changes the DNS filtering mode.
message SetDnsMode { DnsMode mode = 1; }
