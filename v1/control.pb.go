// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: v1/control.proto

package apiv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// UnsubscribeReason explains why an attachment was unsubscribed.
type UnsubscribeReason int32

const (
	UnsubscribeReason_UNSUBSCRIBE_REASON_UNSPECIFIED UnsubscribeReason = 0
	// Target no longer exists in the system (interface removed, cgroup gone)
	UnsubscribeReason_UNSUBSCRIBE_REASON_REMOVED UnsubscribeReason = 1
	// Explicit detach request via local API
	UnsubscribeReason_UNSUBSCRIBE_REASON_DETACHED UnsubscribeReason = 2
	// Error maintaining the eBPF attachment
	UnsubscribeReason_UNSUBSCRIBE_REASON_ERROR UnsubscribeReason = 3
)

// Enum value maps for UnsubscribeReason.
var (
	UnsubscribeReason_name = map[int32]string{
		0: "UNSUBSCRIBE_REASON_UNSPECIFIED",
		1: "UNSUBSCRIBE_REASON_REMOVED",
		2: "UNSUBSCRIBE_REASON_DETACHED",
		3: "UNSUBSCRIBE_REASON_ERROR",
	}
	UnsubscribeReason_value = map[string]int32{
		"UNSUBSCRIBE_REASON_UNSPECIFIED": 0,
		"UNSUBSCRIBE_REASON_REMOVED":     1,
		"UNSUBSCRIBE_REASON_DETACHED":    2,
		"UNSUBSCRIBE_REASON_ERROR":       3,
	}
)

func (x UnsubscribeReason) Enum() *UnsubscribeReason {
	p := new(UnsubscribeReason)
	*p = x
	return p
}

func (x UnsubscribeReason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (UnsubscribeReason) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_control_proto_enumTypes[0].Descriptor()
}

func (UnsubscribeReason) Type() protoreflect.EnumType {
	return &file_v1_control_proto_enumTypes[0]
}

func (x UnsubscribeReason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use UnsubscribeReason.Descriptor instead.
func (UnsubscribeReason) EnumDescriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{0}
}

// DaemonEvent represents events sent from the daemon to the control plane.
type DaemonEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Event:
	//
	//	*DaemonEvent_Sync
	//	*DaemonEvent_Subscribed
	//	*DaemonEvent_Unsubscribed
	//	*DaemonEvent_Heartbeat
	Event         isDaemonEvent_Event `protobuf_oneof:"event"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DaemonEvent) Reset() {
	*x = DaemonEvent{}
	mi := &file_v1_control_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DaemonEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DaemonEvent) ProtoMessage() {}

func (x *DaemonEvent) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DaemonEvent.ProtoReflect.Descriptor instead.
func (*DaemonEvent) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{0}
}

func (x *DaemonEvent) GetEvent() isDaemonEvent_Event {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *DaemonEvent) GetSync() *SyncRequest {
	if x != nil {
		if x, ok := x.Event.(*DaemonEvent_Sync); ok {
			return x.Sync
		}
	}
	return nil
}

func (x *DaemonEvent) GetSubscribed() *Subscribed {
	if x != nil {
		if x, ok := x.Event.(*DaemonEvent_Subscribed); ok {
			return x.Subscribed
		}
	}
	return nil
}

func (x *DaemonEvent) GetUnsubscribed() *Unsubscribed {
	if x != nil {
		if x, ok := x.Event.(*DaemonEvent_Unsubscribed); ok {
			return x.Unsubscribed
		}
	}
	return nil
}

func (x *DaemonEvent) GetHeartbeat() *Heartbeat {
	if x != nil {
		if x, ok := x.Event.(*DaemonEvent_Heartbeat); ok {
			return x.Heartbeat
		}
	}
	return nil
}

type isDaemonEvent_Event interface {
	isDaemonEvent_Event()
}

type DaemonEvent_Sync struct {
	// Initial sync request sent on connect/reconnect
	Sync *SyncRequest `protobuf:"bytes,1,opt,name=sync,proto3,oneof"`
}

type DaemonEvent_Subscribed struct {
	// Notification that a new attachment is now subscribed
	Subscribed *Subscribed `protobuf:"bytes,2,opt,name=subscribed,proto3,oneof"`
}

type DaemonEvent_Unsubscribed struct {
	// Notification that an attachment has been unsubscribed
	Unsubscribed *Unsubscribed `protobuf:"bytes,3,opt,name=unsubscribed,proto3,oneof"`
}

type DaemonEvent_Heartbeat struct {
	// Periodic heartbeat with optional stats
	Heartbeat *Heartbeat `protobuf:"bytes,4,opt,name=heartbeat,proto3,oneof"`
}

func (*DaemonEvent_Sync) isDaemonEvent_Event() {}

func (*DaemonEvent_Subscribed) isDaemonEvent_Event() {}

func (*DaemonEvent_Unsubscribed) isDaemonEvent_Event() {}

func (*DaemonEvent_Heartbeat) isDaemonEvent_Event() {}

// SyncRequest is sent when the daemon connects or reconnects.
// It lists all current attachments so the control plane can resync.
type SyncRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Daemon instance identifier (stable across restarts)
	DaemonId string `protobuf:"bytes,1,opt,name=daemon_id,json=daemonId,proto3" json:"daemon_id,omitempty"`
	// Hostname for identification
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// All current attachments managed by this daemon
	Attachments   []*Attachment `protobuf:"bytes,3,rep,name=attachments,proto3" json:"attachments,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SyncRequest) Reset() {
	*x = SyncRequest{}
	mi := &file_v1_control_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SyncRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SyncRequest) ProtoMessage() {}

func (x *SyncRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SyncRequest.ProtoReflect.Descriptor instead.
func (*SyncRequest) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{1}
}

func (x *SyncRequest) GetDaemonId() string {
	if x != nil {
		return x.DaemonId
	}
	return ""
}

func (x *SyncRequest) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *SyncRequest) GetAttachments() []*Attachment {
	if x != nil {
		return x.Attachments
	}
	return nil
}

// Attachment describes a filter attachment managed by the daemon.
type Attachment struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for this attachment
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The target (interface name or cgroup path)
	Target string `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	// Type of attachment
	Type AttachmentType `protobuf:"varint,3,opt,name=type,proto3,enum=superebpf.v1.AttachmentType" json:"type,omitempty"`
	// Current policy mode
	Mode PolicyMode `protobuf:"varint,4,opt,name=mode,proto3,enum=superebpf.v1.PolicyMode" json:"mode,omitempty"`
	// User-defined metadata (VM ID, tenant, etc.)
	Metadata      map[string]string `protobuf:"bytes,5,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Attachment) Reset() {
	*x = Attachment{}
	mi := &file_v1_control_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Attachment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Attachment) ProtoMessage() {}

func (x *Attachment) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Attachment.ProtoReflect.Descriptor instead.
func (*Attachment) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{2}
}

func (x *Attachment) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Attachment) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *Attachment) GetType() AttachmentType {
	if x != nil {
		return x.Type
	}
	return AttachmentType_ATTACHMENT_TYPE_UNSPECIFIED
}

func (x *Attachment) GetMode() PolicyMode {
	if x != nil {
		return x.Mode
	}
	return PolicyMode_POLICY_MODE_UNSPECIFIED
}

func (x *Attachment) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// Subscribed notifies that a new filter attachment is now managed.
type Subscribed struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for this attachment
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The target (interface name or cgroup path)
	Target string `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	// Type of attachment
	Type AttachmentType `protobuf:"varint,3,opt,name=type,proto3,enum=superebpf.v1.AttachmentType" json:"type,omitempty"`
	// Initial policy mode
	Mode PolicyMode `protobuf:"varint,4,opt,name=mode,proto3,enum=superebpf.v1.PolicyMode" json:"mode,omitempty"`
	// User-defined metadata for associating with VM ID, tenant, etc.
	Metadata      map[string]string `protobuf:"bytes,5,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Subscribed) Reset() {
	*x = Subscribed{}
	mi := &file_v1_control_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Subscribed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Subscribed) ProtoMessage() {}

func (x *Subscribed) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Subscribed.ProtoReflect.Descriptor instead.
func (*Subscribed) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{3}
}

func (x *Subscribed) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Subscribed) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *Subscribed) GetType() AttachmentType {
	if x != nil {
		return x.Type
	}
	return AttachmentType_ATTACHMENT_TYPE_UNSPECIFIED
}

func (x *Subscribed) GetMode() PolicyMode {
	if x != nil {
		return x.Mode
	}
	return PolicyMode_POLICY_MODE_UNSPECIFIED
}

func (x *Subscribed) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// Unsubscribed notifies that an attachment is no longer managed.
type Unsubscribed struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The attachment that was removed
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Reason for removal
	Reason UnsubscribeReason `protobuf:"varint,2,opt,name=reason,proto3,enum=superebpf.v1.UnsubscribeReason" json:"reason,omitempty"`
	// Error message if reason is ERROR
	Error         string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Unsubscribed) Reset() {
	*x = Unsubscribed{}
	mi := &file_v1_control_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Unsubscribed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Unsubscribed) ProtoMessage() {}

func (x *Unsubscribed) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Unsubscribed.ProtoReflect.Descriptor instead.
func (*Unsubscribed) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{4}
}

func (x *Unsubscribed) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Unsubscribed) GetReason() UnsubscribeReason {
	if x != nil {
		return x.Reason
	}
	return UnsubscribeReason_UNSUBSCRIBE_REASON_UNSPECIFIED
}

func (x *Unsubscribed) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Heartbeat is sent periodically to keep the connection alive and report stats.
type Heartbeat struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Stats         []*AttachmentStats     `protobuf:"bytes,1,rep,name=stats,proto3" json:"stats,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Heartbeat) Reset() {
	*x = Heartbeat{}
	mi := &file_v1_control_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Heartbeat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Heartbeat) ProtoMessage() {}

func (x *Heartbeat) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Heartbeat.ProtoReflect.Descriptor instead.
func (*Heartbeat) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{5}
}

func (x *Heartbeat) GetStats() []*AttachmentStats {
	if x != nil {
		return x.Stats
	}
	return nil
}

// AttachmentStats reports statistics for a single attachment.
type AttachmentStats struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Id             string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	PacketsAllowed uint64                 `protobuf:"varint,2,opt,name=packets_allowed,json=packetsAllowed,proto3" json:"packets_allowed,omitempty"`
	PacketsBlocked uint64                 `protobuf:"varint,3,opt,name=packets_blocked,json=packetsBlocked,proto3" json:"packets_blocked,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *AttachmentStats) Reset() {
	*x = AttachmentStats{}
	mi := &file_v1_control_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttachmentStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttachmentStats) ProtoMessage() {}

func (x *AttachmentStats) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttachmentStats.ProtoReflect.Descriptor instead.
func (*AttachmentStats) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{6}
}

func (x *AttachmentStats) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *AttachmentStats) GetPacketsAllowed() uint64 {
	if x != nil {
		return x.PacketsAllowed
	}
	return 0
}

func (x *AttachmentStats) GetPacketsBlocked() uint64 {
	if x != nil {
		return x.PacketsBlocked
	}
	return 0
}

// ControlCommand represents commands sent from the control plane to the daemon.
type ControlCommand struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Target attachment ID
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Types that are valid to be assigned to Command:
	//
	//	*ControlCommand_SyncAck
	//	*ControlCommand_SetMode
	//	*ControlCommand_AllowCidr
	//	*ControlCommand_DenyCidr
	//	*ControlCommand_RemoveCidr
	//	*ControlCommand_BulkUpdate
	Command       isControlCommand_Command `protobuf_oneof:"command"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControlCommand) Reset() {
	*x = ControlCommand{}
	mi := &file_v1_control_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControlCommand) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControlCommand) ProtoMessage() {}

func (x *ControlCommand) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControlCommand.ProtoReflect.Descriptor instead.
func (*ControlCommand) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{7}
}

func (x *ControlCommand) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ControlCommand) GetCommand() isControlCommand_Command {
	if x != nil {
		return x.Command
	}
	return nil
}

func (x *ControlCommand) GetSyncAck() *SyncAck {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_SyncAck); ok {
			return x.SyncAck
		}
	}
	return nil
}

func (x *ControlCommand) GetSetMode() *SetMode {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_SetMode); ok {
			return x.SetMode
		}
	}
	return nil
}

func (x *ControlCommand) GetAllowCidr() *AllowCIDR {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_AllowCidr); ok {
			return x.AllowCidr
		}
	}
	return nil
}

func (x *ControlCommand) GetDenyCidr() *DenyCIDR {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_DenyCidr); ok {
			return x.DenyCidr
		}
	}
	return nil
}

func (x *ControlCommand) GetRemoveCidr() *RemoveCIDR {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_RemoveCidr); ok {
			return x.RemoveCidr
		}
	}
	return nil
}

func (x *ControlCommand) GetBulkUpdate() *BulkUpdate {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_BulkUpdate); ok {
			return x.BulkUpdate
		}
	}
	return nil
}

type isControlCommand_Command interface {
	isControlCommand_Command()
}

type ControlCommand_SyncAck struct {
	// Acknowledge sync (sent after receiving SyncRequest)
	SyncAck *SyncAck `protobuf:"bytes,2,opt,name=sync_ack,json=syncAck,proto3,oneof"`
}

type ControlCommand_SetMode struct {
	// Change the policy mode
	SetMode *SetMode `protobuf:"bytes,3,opt,name=set_mode,json=setMode,proto3,oneof"`
}

type ControlCommand_AllowCidr struct {
	// Add a CIDR to the allowlist
	AllowCidr *AllowCIDR `protobuf:"bytes,4,opt,name=allow_cidr,json=allowCidr,proto3,oneof"`
}

type ControlCommand_DenyCidr struct {
	// Add a CIDR to the denylist
	DenyCidr *DenyCIDR `protobuf:"bytes,5,opt,name=deny_cidr,json=denyCidr,proto3,oneof"`
}

type ControlCommand_RemoveCidr struct {
	// Remove a CIDR from allow/deny lists
	RemoveCidr *RemoveCIDR `protobuf:"bytes,6,opt,name=remove_cidr,json=removeCidr,proto3,oneof"`
}

type ControlCommand_BulkUpdate struct {
	// Bulk update - set complete state for an attachment
	BulkUpdate *BulkUpdate `protobuf:"bytes,7,opt,name=bulk_update,json=bulkUpdate,proto3,oneof"`
}

func (*ControlCommand_SyncAck) isControlCommand_Command() {}

func (*ControlCommand_SetMode) isControlCommand_Command() {}

func (*ControlCommand_AllowCidr) isControlCommand_Command() {}

func (*ControlCommand_DenyCidr) isControlCommand_Command() {}

func (*ControlCommand_RemoveCidr) isControlCommand_Command() {}

func (*ControlCommand_BulkUpdate) isControlCommand_Command() {}

// SyncAck acknowledges that the control plane has processed the SyncRequest.
type SyncAck struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SyncAck) Reset() {
	*x = SyncAck{}
	mi := &file_v1_control_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SyncAck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SyncAck) ProtoMessage() {}

func (x *SyncAck) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SyncAck.ProtoReflect.Descriptor instead.
func (*SyncAck) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{8}
}

// SetMode changes the policy mode for an attachment.
type SetMode struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Mode          PolicyMode             `protobuf:"varint,1,opt,name=mode,proto3,enum=superebpf.v1.PolicyMode" json:"mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetMode) Reset() {
	*x = SetMode{}
	mi := &file_v1_control_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetMode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetMode) ProtoMessage() {}

func (x *SetMode) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetMode.ProtoReflect.Descriptor instead.
func (*SetMode) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{9}
}

func (x *SetMode) GetMode() PolicyMode {
	if x != nil {
		return x.Mode
	}
	return PolicyMode_POLICY_MODE_UNSPECIFIED
}

// AllowCIDR adds a CIDR to the allowlist.
type AllowCIDR struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IPv4 or IPv6 CIDR (e.g., "10.0.0.0/8", "2001:db8::/32", or single IP "1.2.3.4")
	Cidr string `protobuf:"bytes,1,opt,name=cidr,proto3" json:"cidr,omitempty"`
	// Optional TTL - daemon will automatically remove after this duration.
	// Zero or unset means no expiration.
	Ttl           *durationpb.Duration `protobuf:"bytes,2,opt,name=ttl,proto3" json:"ttl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AllowCIDR) Reset() {
	*x = AllowCIDR{}
	mi := &file_v1_control_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AllowCIDR) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllowCIDR) ProtoMessage() {}

func (x *AllowCIDR) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllowCIDR.ProtoReflect.Descriptor instead.
func (*AllowCIDR) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{10}
}

func (x *AllowCIDR) GetCidr() string {
	if x != nil {
		return x.Cidr
	}
	return ""
}

func (x *AllowCIDR) GetTtl() *durationpb.Duration {
	if x != nil {
		return x.Ttl
	}
	return nil
}

// DenyCIDR adds a CIDR to the denylist.
type DenyCIDR struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IPv4 or IPv6 CIDR
	Cidr string `protobuf:"bytes,1,opt,name=cidr,proto3" json:"cidr,omitempty"`
	// Optional TTL for automatic expiration
	Ttl           *durationpb.Duration `protobuf:"bytes,2,opt,name=ttl,proto3" json:"ttl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DenyCIDR) Reset() {
	*x = DenyCIDR{}
	mi := &file_v1_control_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DenyCIDR) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DenyCIDR) ProtoMessage() {}

func (x *DenyCIDR) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DenyCIDR.ProtoReflect.Descriptor instead.
func (*DenyCIDR) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{11}
}

func (x *DenyCIDR) GetCidr() string {
	if x != nil {
		return x.Cidr
	}
	return ""
}

func (x *DenyCIDR) GetTtl() *durationpb.Duration {
	if x != nil {
		return x.Ttl
	}
	return nil
}

// RemoveCIDR removes a CIDR from both allow and deny lists.
type RemoveCIDR struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Cidr          string                 `protobuf:"bytes,1,opt,name=cidr,proto3" json:"cidr,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoveCIDR) Reset() {
	*x = RemoveCIDR{}
	mi := &file_v1_control_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoveCIDR) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveCIDR) ProtoMessage() {}

func (x *RemoveCIDR) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveCIDR.ProtoReflect.Descriptor instead.
func (*RemoveCIDR) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{12}
}

func (x *RemoveCIDR) GetCidr() string {
	if x != nil {
		return x.Cidr
	}
	return ""
}

// BulkUpdate sets the complete state for an attachment.
// Clears existing rules and replaces with the provided state.
type BulkUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Policy mode to set
	Mode PolicyMode `protobuf:"varint,1,opt,name=mode,proto3,enum=superebpf.v1.PolicyMode" json:"mode,omitempty"`
	// CIDRs to allow
	AllowCidrs []*CIDREntry `protobuf:"bytes,2,rep,name=allow_cidrs,json=allowCidrs,proto3" json:"allow_cidrs,omitempty"`
	// CIDRs to deny
	DenyCidrs     []*CIDREntry `protobuf:"bytes,3,rep,name=deny_cidrs,json=denyCidrs,proto3" json:"deny_cidrs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BulkUpdate) Reset() {
	*x = BulkUpdate{}
	mi := &file_v1_control_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BulkUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BulkUpdate) ProtoMessage() {}

func (x *BulkUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BulkUpdate.ProtoReflect.Descriptor instead.
func (*BulkUpdate) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{13}
}

func (x *BulkUpdate) GetMode() PolicyMode {
	if x != nil {
		return x.Mode
	}
	return PolicyMode_POLICY_MODE_UNSPECIFIED
}

func (x *BulkUpdate) GetAllowCidrs() []*CIDREntry {
	if x != nil {
		return x.AllowCidrs
	}
	return nil
}

func (x *BulkUpdate) GetDenyCidrs() []*CIDREntry {
	if x != nil {
		return x.DenyCidrs
	}
	return nil
}

// CIDREntry represents a CIDR with optional TTL.
type CIDREntry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Cidr          string                 `protobuf:"bytes,1,opt,name=cidr,proto3" json:"cidr,omitempty"`
	Ttl           *durationpb.Duration   `protobuf:"bytes,2,opt,name=ttl,proto3" json:"ttl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CIDREntry) Reset() {
	*x = CIDREntry{}
	mi := &file_v1_control_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CIDREntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CIDREntry) ProtoMessage() {}

func (x *CIDREntry) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CIDREntry.ProtoReflect.Descriptor instead.
func (*CIDREntry) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{14}
}

func (x *CIDREntry) GetCidr() string {
	if x != nil {
		return x.Cidr
	}
	return ""
}

func (x *CIDREntry) GetTtl() *durationpb.Duration {
	if x != nil {
		return x.Ttl
	}
	return nil
}

var File_v1_control_proto protoreflect.FileDescriptor

const file_v1_control_proto_rawDesc = "" +
	"\n" +
	"\x10v1/control.proto\x12\fsuperebpf.v1\x1a\x1egoogle/protobuf/duration.proto\x1a\x0ev1/types.proto\"\xfe\x01\n" +
	"\vDaemonEvent\x12/\n" +
	"\x04sync\x18\x01 \x01(\v2\x19.superebpf.v1.SyncRequestH\x00R\x04sync\x12:\n" +
	"\n" +
	"subscribed\x18\x02 \x01(\v2\x18.superebpf.v1.SubscribedH\x00R\n" +
	"subscribed\x12@\n" +
	"\funsubscribed\x18\x03 \x01(\v2\x1a.superebpf.v1.UnsubscribedH\x00R\funsubscribed\x127\n" +
	"\theartbeat\x18\x04 \x01(\v2\x17.superebpf.v1.HeartbeatH\x00R\theartbeatB\a\n" +
	"\x05event\"\x82\x01\n" +
	"\vSyncRequest\x12\x1b\n" +
	"\tdaemon_id\x18\x01 \x01(\tR\bdaemonId\x12\x1a\n" +
	"\bhostname\x18\x02 \x01(\tR\bhostname\x12:\n" +
	"\vattachments\x18\x03 \x03(\v2\x18.superebpf.v1.AttachmentR\vattachments\"\x95\x02\n" +
	"\n" +
	"Attachment\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x16\n" +
	"\x06target\x18\x02 \x01(\tR\x06target\x120\n" +
	"\x04type\x18\x03 \x01(\x0e2\x1c.superebpf.v1.AttachmentTypeR\x04type\x12,\n" +
	"\x04mode\x18\x04 \x01(\x0e2\x18.superebpf.v1.PolicyModeR\x04mode\x12B\n" +
	"\bmetadata\x18\x05 \x03(\v2&.superebpf.v1.Attachment.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x95\x02\n" +
	"\n" +
	"Subscribed\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x16\n" +
	"\x06target\x18\x02 \x01(\tR\x06target\x120\n" +
	"\x04type\x18\x03 \x01(\x0e2\x1c.superebpf.v1.AttachmentTypeR\x04type\x12,\n" +
	"\x04mode\x18\x04 \x01(\x0e2\x18.superebpf.v1.PolicyModeR\x04mode\x12B\n" +
	"\bmetadata\x18\x05 \x03(\v2&.superebpf.v1.Subscribed.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"m\n" +
	"\fUnsubscribed\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x127\n" +
	"\x06reason\x18\x02 \x01(\x0e2\x1f.superebpf.v1.UnsubscribeReasonR\x06reason\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\"@\n" +
	"\tHeartbeat\x123\n" +
	"\x05stats\x18\x01 \x03(\v2\x1d.superebpf.v1.AttachmentStatsR\x05stats\"s\n" +
	"\x0fAttachmentStats\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12'\n" +
	"\x0fpackets_allowed\x18\x02 \x01(\x04R\x0epacketsAllowed\x12'\n" +
	"\x0fpackets_blocked\x18\x03 \x01(\x04R\x0epacketsBlocked\"\xfe\x02\n" +
	"\x0eControlCommand\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x122\n" +
	"\bsync_ack\x18\x02 \x01(\v2\x15.superebpf.v1.SyncAckH\x00R\asyncAck\x122\n" +
	"\bset_mode\x18\x03 \x01(\v2\x15.superebpf.v1.SetModeH\x00R\asetMode\x128\n" +
	"\n" +
	"allow_cidr\x18\x04 \x01(\v2\x17.superebpf.v1.AllowCIDRH\x00R\tallowCidr\x125\n" +
	"\tdeny_cidr\x18\x05 \x01(\v2\x16.superebpf.v1.DenyCIDRH\x00R\bdenyCidr\x12;\n" +
	"\vremove_cidr\x18\x06 \x01(\v2\x18.superebpf.v1.RemoveCIDRH\x00R\n" +
	"removeCidr\x12;\n" +
	"\vbulk_update\x18\a \x01(\v2\x18.superebpf.v1.BulkUpdateH\x00R\n" +
	"bulkUpdateB\t\n" +
	"\acommand\"\t\n" +
	"\aSyncAck\"7\n" +
	"\aSetMode\x12,\n" +
	"\x04mode\x18\x01 \x01(\x0e2\x18.superebpf.v1.PolicyModeR\x04mode\"L\n" +
	"\tAllowCIDR\x12\x12\n" +
	"\x04cidr\x18\x01 \x01(\tR\x04cidr\x12+\n" +
	"\x03ttl\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\x03ttl\"K\n" +
	"\bDenyCIDR\x12\x12\n" +
	"\x04cidr\x18\x01 \x01(\tR\x04cidr\x12+\n" +
	"\x03ttl\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\x03ttl\" \n" +
	"\n" +
	"RemoveCIDR\x12\x12\n" +
	"\x04cidr\x18\x01 \x01(\tR\x04cidr\"\xac\x01\n" +
	"\n" +
	"BulkUpdate\x12,\n" +
	"\x04mode\x18\x01 \x01(\x0e2\x18.superebpf.v1.PolicyModeR\x04mode\x128\n" +
	"\vallow_cidrs\x18\x02 \x03(\v2\x17.superebpf.v1.CIDREntryR\n" +
	"allowCidrs\x126\n" +
	"\n" +
	"deny_cidrs\x18\x03 \x03(\v2\x17.superebpf.v1.CIDREntryR\tdenyCidrs\"L\n" +
	"\tCIDREntry\x12\x12\n" +
	"\x04cidr\x18\x01 \x01(\tR\x04cidr\x12+\n" +
	"\x03ttl\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\x03ttl*\x96\x01\n" +
	"\x11UnsubscribeReason\x12\"\n" +
	"\x1eUNSUBSCRIBE_REASON_UNSPECIFIED\x10\x00\x12\x1e\n" +
	"\x1aUNSUBSCRIBE_REASON_REMOVED\x10\x01\x12\x1f\n" +
	"\x1bUNSUBSCRIBE_REASON_DETACHED\x10\x02\x12\x1c\n" +
	"\x18UNSUBSCRIBE_REASON_ERROR\x10\x032V\n" +
	"\fControlPlane\x12F\n" +
	"\aConnect\x12\x19.superebpf.v1.DaemonEvent\x1a\x1c.superebpf.v1.ControlCommand(\x010\x01B2Z0github.com/danthegoodman1/superebpf/api/v1;apiv1b\x06proto3"

var (
	file_v1_control_proto_rawDescOnce sync.Once
	file_v1_control_proto_rawDescData []byte
)

func file_v1_control_proto_rawDescGZIP() []byte {
	file_v1_control_proto_rawDescOnce.Do(func() {
		file_v1_control_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_v1_control_proto_rawDesc), len(file_v1_control_proto_rawDesc)))
	})
	return file_v1_control_proto_rawDescData
}

var file_v1_control_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_v1_control_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_v1_control_proto_goTypes = []any{
	(UnsubscribeReason)(0),      // 0: superebpf.v1.UnsubscribeReason
	(*DaemonEvent)(nil),         // 1: superebpf.v1.DaemonEvent
	(*SyncRequest)(nil),         // 2: superebpf.v1.SyncRequest
	(*Attachment)(nil),          // 3: superebpf.v1.Attachment
	(*Subscribed)(nil),          // 4: superebpf.v1.Subscribed
	(*Unsubscribed)(nil),        // 5: superebpf.v1.Unsubscribed
	(*Heartbeat)(nil),           // 6: superebpf.v1.Heartbeat
	(*AttachmentStats)(nil),     // 7: superebpf.v1.AttachmentStats
	(*ControlCommand)(nil),      // 8: superebpf.v1.ControlCommand
	(*SyncAck)(nil),             // 9: superebpf.v1.SyncAck
	(*SetMode)(nil),             // 10: superebpf.v1.SetMode
	(*AllowCIDR)(nil),           // 11: superebpf.v1.AllowCIDR
	(*DenyCIDR)(nil),            // 12: superebpf.v1.DenyCIDR
	(*RemoveCIDR)(nil),          // 13: superebpf.v1.RemoveCIDR
	(*BulkUpdate)(nil),          // 14: superebpf.v1.BulkUpdate
	(*CIDREntry)(nil),           // 15: superebpf.v1.CIDREntry
	nil,                         // 16: superebpf.v1.Attachment.MetadataEntry
	nil,                         // 17: superebpf.v1.Subscribed.MetadataEntry
	(AttachmentType)(0),         // 18: superebpf.v1.AttachmentType
	(PolicyMode)(0),             // 19: superebpf.v1.PolicyMode
	(*durationpb.Duration)(nil), // 20: google.protobuf.Duration
}
var file_v1_control_proto_depIdxs = []int32{
	2,  // 0: superebpf.v1.DaemonEvent.sync:type_name -> superebpf.v1.SyncRequest
	4,  // 1: superebpf.v1.DaemonEvent.subscribed:type_name -> superebpf.v1.Subscribed
	5,  // 2: superebpf.v1.DaemonEvent.unsubscribed:type_name -> superebpf.v1.Unsubscribed
	6,  // 3: superebpf.v1.DaemonEvent.heartbeat:type_name -> superebpf.v1.Heartbeat
	3,  // 4: superebpf.v1.SyncRequest.attachments:type_name -> superebpf.v1.Attachment
	18, // 5: superebpf.v1.Attachment.type:type_name -> superebpf.v1.AttachmentType
	19, // 6: superebpf.v1.Attachment.mode:type_name -> superebpf.v1.PolicyMode
	16, // 7: superebpf.v1.Attachment.metadata:type_name -> superebpf.v1.Attachment.MetadataEntry
	18, // 8: superebpf.v1.Subscribed.type:type_name -> superebpf.v1.AttachmentType
	19, // 9: superebpf.v1.Subscribed.mode:type_name -> superebpf.v1.PolicyMode
	17, // 10: superebpf.v1.Subscribed.metadata:type_name -> superebpf.v1.Subscribed.MetadataEntry
	0,  // 11: superebpf.v1.Unsubscribed.reason:type_name -> superebpf.v1.UnsubscribeReason
	7,  // 12: superebpf.v1.Heartbeat.stats:type_name -> superebpf.v1.AttachmentStats
	9,  // 13: superebpf.v1.ControlCommand.sync_ack:type_name -> superebpf.v1.SyncAck
	10, // 14: superebpf.v1.ControlCommand.set_mode:type_name -> superebpf.v1.SetMode
	11, // 15: superebpf.v1.ControlCommand.allow_cidr:type_name -> superebpf.v1.AllowCIDR
	12, // 16: superebpf.v1.ControlCommand.deny_cidr:type_name -> superebpf.v1.DenyCIDR
	13, // 17: superebpf.v1.ControlCommand.remove_cidr:type_name -> superebpf.v1.RemoveCIDR
	14, // 18: superebpf.v1.ControlCommand.bulk_update:type_name -> superebpf.v1.BulkUpdate
	19, // 19: superebpf.v1.SetMode.mode:type_name -> superebpf.v1.PolicyMode
	20, // 20: superebpf.v1.AllowCIDR.ttl:type_name -> google.protobuf.Duration
	20, // 21: superebpf.v1.DenyCIDR.ttl:type_name -> google.protobuf.Duration
	19, // 22: superebpf.v1.BulkUpdate.mode:type_name -> superebpf.v1.PolicyMode
	15, // 23: superebpf.v1.BulkUpdate.allow_cidrs:type_name -> superebpf.v1.CIDREntry
	15, // 24: superebpf.v1.BulkUpdate.deny_cidrs:type_name -> superebpf.v1.CIDREntry
	20, // 25: superebpf.v1.CIDREntry.ttl:type_name -> google.protobuf.Duration
	1,  // 26: superebpf.v1.ControlPlane.Connect:input_type -> superebpf.v1.DaemonEvent
	8,  // 27: superebpf.v1.ControlPlane.Connect:output_type -> superebpf.v1.ControlCommand
	27, // [27:28] is the sub-list for method output_type
	26, // [26:27] is the sub-list for method input_type
	26, // [26:26] is the sub-list for extension type_name
	26, // [26:26] is the sub-list for extension extendee
	0,  // [0:26] is the sub-list for field type_name
}

func init() { file_v1_control_proto_init() }
func file_v1_control_proto_init() {
	if File_v1_control_proto != nil {
		return
	}
	file_v1_types_proto_init()
	file_v1_control_proto_msgTypes[0].OneofWrappers = []any{
		(*DaemonEvent_Sync)(nil),
		(*DaemonEvent_Subscribed)(nil),
		(*DaemonEvent_Unsubscribed)(nil),
		(*DaemonEvent_Heartbeat)(nil),
	}
	file_v1_control_proto_msgTypes[7].OneofWrappers = []any{
		(*ControlCommand_SyncAck)(nil),
		(*ControlCommand_SetMode)(nil),
		(*ControlCommand_AllowCidr)(nil),
		(*ControlCommand_DenyCidr)(nil),
		(*ControlCommand_RemoveCidr)(nil),
		(*ControlCommand_BulkUpdate)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_v1_control_proto_rawDesc), len(file_v1_control_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_v1_control_proto_goTypes,
		DependencyIndexes: file_v1_control_proto_depIdxs,
		EnumInfos:         file_v1_control_proto_enumTypes,
		MessageInfos:      file_v1_control_proto_msgTypes,
	}.Build()
	File_v1_control_proto = out.File
	file_v1_control_proto_goTypes = nil
	file_v1_control_proto_depIdxs = nil
}
