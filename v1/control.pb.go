// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: v1/control.proto

package apiv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// UnsubscribeReason explains why an attachment was unsubscribed.
type UnsubscribeReason int32

const (
	UnsubscribeReason_UNSUBSCRIBE_REASON_UNSPECIFIED UnsubscribeReason = 0
	// Target no longer exists in the system (interface removed, cgroup gone)
	UnsubscribeReason_UNSUBSCRIBE_REASON_REMOVED UnsubscribeReason = 1
	// Explicit detach request via local API
	UnsubscribeReason_UNSUBSCRIBE_REASON_DETACHED UnsubscribeReason = 2
	// Error maintaining the eBPF attachment
	UnsubscribeReason_UNSUBSCRIBE_REASON_ERROR UnsubscribeReason = 3
)

// Enum value maps for UnsubscribeReason.
var (
	UnsubscribeReason_name = map[int32]string{
		0: "UNSUBSCRIBE_REASON_UNSPECIFIED",
		1: "UNSUBSCRIBE_REASON_REMOVED",
		2: "UNSUBSCRIBE_REASON_DETACHED",
		3: "UNSUBSCRIBE_REASON_ERROR",
	}
	UnsubscribeReason_value = map[string]int32{
		"UNSUBSCRIBE_REASON_UNSPECIFIED": 0,
		"UNSUBSCRIBE_REASON_REMOVED":     1,
		"UNSUBSCRIBE_REASON_DETACHED":    2,
		"UNSUBSCRIBE_REASON_ERROR":       3,
	}
)

func (x UnsubscribeReason) Enum() *UnsubscribeReason {
	p := new(UnsubscribeReason)
	*p = x
	return p
}

func (x UnsubscribeReason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (UnsubscribeReason) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_control_proto_enumTypes[0].Descriptor()
}

func (UnsubscribeReason) Type() protoreflect.EnumType {
	return &file_v1_control_proto_enumTypes[0]
}

func (x UnsubscribeReason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use UnsubscribeReason.Descriptor instead.
func (UnsubscribeReason) EnumDescriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{0}
}

// DaemonEvent represents events sent from the daemon to the control plane.
type DaemonEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Event:
	//
	//	*DaemonEvent_Sync
	//	*DaemonEvent_Subscribed
	//	*DaemonEvent_Unsubscribed
	//	*DaemonEvent_Heartbeat
	Event         isDaemonEvent_Event `protobuf_oneof:"event"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DaemonEvent) Reset() {
	*x = DaemonEvent{}
	mi := &file_v1_control_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DaemonEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DaemonEvent) ProtoMessage() {}

func (x *DaemonEvent) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DaemonEvent.ProtoReflect.Descriptor instead.
func (*DaemonEvent) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{0}
}

func (x *DaemonEvent) GetEvent() isDaemonEvent_Event {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *DaemonEvent) GetSync() *SyncRequest {
	if x != nil {
		if x, ok := x.Event.(*DaemonEvent_Sync); ok {
			return x.Sync
		}
	}
	return nil
}

func (x *DaemonEvent) GetSubscribed() *Subscribed {
	if x != nil {
		if x, ok := x.Event.(*DaemonEvent_Subscribed); ok {
			return x.Subscribed
		}
	}
	return nil
}

func (x *DaemonEvent) GetUnsubscribed() *Unsubscribed {
	if x != nil {
		if x, ok := x.Event.(*DaemonEvent_Unsubscribed); ok {
			return x.Unsubscribed
		}
	}
	return nil
}

func (x *DaemonEvent) GetHeartbeat() *Heartbeat {
	if x != nil {
		if x, ok := x.Event.(*DaemonEvent_Heartbeat); ok {
			return x.Heartbeat
		}
	}
	return nil
}

type isDaemonEvent_Event interface {
	isDaemonEvent_Event()
}

type DaemonEvent_Sync struct {
	// Initial sync request sent on connect/reconnect
	Sync *SyncRequest `protobuf:"bytes,1,opt,name=sync,proto3,oneof"`
}

type DaemonEvent_Subscribed struct {
	// Notification that a new attachment is now subscribed
	Subscribed *Subscribed `protobuf:"bytes,2,opt,name=subscribed,proto3,oneof"`
}

type DaemonEvent_Unsubscribed struct {
	// Notification that an attachment has been unsubscribed
	Unsubscribed *Unsubscribed `protobuf:"bytes,3,opt,name=unsubscribed,proto3,oneof"`
}

type DaemonEvent_Heartbeat struct {
	// Periodic heartbeat with optional stats
	Heartbeat *Heartbeat `protobuf:"bytes,4,opt,name=heartbeat,proto3,oneof"`
}

func (*DaemonEvent_Sync) isDaemonEvent_Event() {}

func (*DaemonEvent_Subscribed) isDaemonEvent_Event() {}

func (*DaemonEvent_Unsubscribed) isDaemonEvent_Event() {}

func (*DaemonEvent_Heartbeat) isDaemonEvent_Event() {}

// SyncRequest is sent when the daemon connects or reconnects.
// It lists all current attachments so the control plane can resync.
type SyncRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Daemon instance identifier (stable across restarts)
	DaemonId string `protobuf:"bytes,1,opt,name=daemon_id,json=daemonId,proto3" json:"daemon_id,omitempty"`
	// Hostname for identification
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// All current attachments managed by this daemon
	Attachments   []*Attachment `protobuf:"bytes,3,rep,name=attachments,proto3" json:"attachments,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SyncRequest) Reset() {
	*x = SyncRequest{}
	mi := &file_v1_control_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SyncRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SyncRequest) ProtoMessage() {}

func (x *SyncRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SyncRequest.ProtoReflect.Descriptor instead.
func (*SyncRequest) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{1}
}

func (x *SyncRequest) GetDaemonId() string {
	if x != nil {
		return x.DaemonId
	}
	return ""
}

func (x *SyncRequest) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *SyncRequest) GetAttachments() []*Attachment {
	if x != nil {
		return x.Attachments
	}
	return nil
}

// Attachment describes a filter attachment managed by the daemon.
type Attachment struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for this attachment
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The target (interface name or cgroup path)
	Target string `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	// Type of attachment
	Type AttachmentType `protobuf:"varint,3,opt,name=type,proto3,enum=netfence.v1.AttachmentType" json:"type,omitempty"`
	// Current IP filter policy mode
	Mode PolicyMode `protobuf:"varint,4,opt,name=mode,proto3,enum=netfence.v1.PolicyMode" json:"mode,omitempty"`
	// Current DNS filtering mode
	DnsMode DnsMode `protobuf:"varint,5,opt,name=dns_mode,json=dnsMode,proto3,enum=netfence.v1.DnsMode" json:"dns_mode,omitempty"`
	// User-defined metadata (VM ID, tenant, etc.)
	Metadata      map[string]string `protobuf:"bytes,6,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Attachment) Reset() {
	*x = Attachment{}
	mi := &file_v1_control_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Attachment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Attachment) ProtoMessage() {}

func (x *Attachment) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Attachment.ProtoReflect.Descriptor instead.
func (*Attachment) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{2}
}

func (x *Attachment) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Attachment) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *Attachment) GetType() AttachmentType {
	if x != nil {
		return x.Type
	}
	return AttachmentType_ATTACHMENT_TYPE_UNSPECIFIED
}

func (x *Attachment) GetMode() PolicyMode {
	if x != nil {
		return x.Mode
	}
	return PolicyMode_POLICY_MODE_UNSPECIFIED
}

func (x *Attachment) GetDnsMode() DnsMode {
	if x != nil {
		return x.DnsMode
	}
	return DnsMode_DNS_MODE_UNSPECIFIED
}

func (x *Attachment) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// Subscribed notifies that a new filter attachment is now managed.
type Subscribed struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for this attachment
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The target (interface name or cgroup path)
	Target string `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	// Type of attachment
	Type AttachmentType `protobuf:"varint,3,opt,name=type,proto3,enum=netfence.v1.AttachmentType" json:"type,omitempty"`
	// Initial IP filter policy mode
	Mode PolicyMode `protobuf:"varint,4,opt,name=mode,proto3,enum=netfence.v1.PolicyMode" json:"mode,omitempty"`
	// Initial DNS filtering mode
	DnsMode DnsMode `protobuf:"varint,5,opt,name=dns_mode,json=dnsMode,proto3,enum=netfence.v1.DnsMode" json:"dns_mode,omitempty"`
	// DNS server address for this attachment (e.g., "10.0.0.1:53")
	// Containers should use this as their DNS resolver
	DnsAddress string `protobuf:"bytes,6,opt,name=dns_address,json=dnsAddress,proto3" json:"dns_address,omitempty"`
	// User-defined metadata for associating with VM ID, tenant, etc.
	Metadata      map[string]string `protobuf:"bytes,7,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Subscribed) Reset() {
	*x = Subscribed{}
	mi := &file_v1_control_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Subscribed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Subscribed) ProtoMessage() {}

func (x *Subscribed) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Subscribed.ProtoReflect.Descriptor instead.
func (*Subscribed) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{3}
}

func (x *Subscribed) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Subscribed) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *Subscribed) GetType() AttachmentType {
	if x != nil {
		return x.Type
	}
	return AttachmentType_ATTACHMENT_TYPE_UNSPECIFIED
}

func (x *Subscribed) GetMode() PolicyMode {
	if x != nil {
		return x.Mode
	}
	return PolicyMode_POLICY_MODE_UNSPECIFIED
}

func (x *Subscribed) GetDnsMode() DnsMode {
	if x != nil {
		return x.DnsMode
	}
	return DnsMode_DNS_MODE_UNSPECIFIED
}

func (x *Subscribed) GetDnsAddress() string {
	if x != nil {
		return x.DnsAddress
	}
	return ""
}

func (x *Subscribed) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// Unsubscribed notifies that an attachment is no longer managed.
type Unsubscribed struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The attachment that was removed
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Reason for removal
	Reason UnsubscribeReason `protobuf:"varint,2,opt,name=reason,proto3,enum=netfence.v1.UnsubscribeReason" json:"reason,omitempty"`
	// Error message if reason is ERROR
	Error         string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Unsubscribed) Reset() {
	*x = Unsubscribed{}
	mi := &file_v1_control_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Unsubscribed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Unsubscribed) ProtoMessage() {}

func (x *Unsubscribed) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Unsubscribed.ProtoReflect.Descriptor instead.
func (*Unsubscribed) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{4}
}

func (x *Unsubscribed) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Unsubscribed) GetReason() UnsubscribeReason {
	if x != nil {
		return x.Reason
	}
	return UnsubscribeReason_UNSUBSCRIBE_REASON_UNSPECIFIED
}

func (x *Unsubscribed) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Heartbeat is sent periodically to keep the connection alive and report stats.
type Heartbeat struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Stats         []*AttachmentStats     `protobuf:"bytes,1,rep,name=stats,proto3" json:"stats,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Heartbeat) Reset() {
	*x = Heartbeat{}
	mi := &file_v1_control_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Heartbeat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Heartbeat) ProtoMessage() {}

func (x *Heartbeat) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Heartbeat.ProtoReflect.Descriptor instead.
func (*Heartbeat) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{5}
}

func (x *Heartbeat) GetStats() []*AttachmentStats {
	if x != nil {
		return x.Stats
	}
	return nil
}

// AttachmentStats reports statistics for a single attachment.
type AttachmentStats struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Id                string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	PacketsAllowed    uint64                 `protobuf:"varint,2,opt,name=packets_allowed,json=packetsAllowed,proto3" json:"packets_allowed,omitempty"`
	PacketsBlocked    uint64                 `protobuf:"varint,3,opt,name=packets_blocked,json=packetsBlocked,proto3" json:"packets_blocked,omitempty"`
	DnsQueriesAllowed uint64                 `protobuf:"varint,4,opt,name=dns_queries_allowed,json=dnsQueriesAllowed,proto3" json:"dns_queries_allowed,omitempty"`
	DnsQueriesBlocked uint64                 `protobuf:"varint,5,opt,name=dns_queries_blocked,json=dnsQueriesBlocked,proto3" json:"dns_queries_blocked,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *AttachmentStats) Reset() {
	*x = AttachmentStats{}
	mi := &file_v1_control_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttachmentStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttachmentStats) ProtoMessage() {}

func (x *AttachmentStats) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttachmentStats.ProtoReflect.Descriptor instead.
func (*AttachmentStats) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{6}
}

func (x *AttachmentStats) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *AttachmentStats) GetPacketsAllowed() uint64 {
	if x != nil {
		return x.PacketsAllowed
	}
	return 0
}

func (x *AttachmentStats) GetPacketsBlocked() uint64 {
	if x != nil {
		return x.PacketsBlocked
	}
	return 0
}

func (x *AttachmentStats) GetDnsQueriesAllowed() uint64 {
	if x != nil {
		return x.DnsQueriesAllowed
	}
	return 0
}

func (x *AttachmentStats) GetDnsQueriesBlocked() uint64 {
	if x != nil {
		return x.DnsQueriesBlocked
	}
	return 0
}

// ControlCommand represents commands sent from the control plane to the daemon.
type ControlCommand struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Target attachment ID
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Types that are valid to be assigned to Command:
	//
	//	*ControlCommand_SyncAck
	//	*ControlCommand_SetMode
	//	*ControlCommand_AllowCidr
	//	*ControlCommand_DenyCidr
	//	*ControlCommand_RemoveCidr
	//	*ControlCommand_BulkUpdate
	//	*ControlCommand_SetDnsMode
	//	*ControlCommand_AllowDomain
	//	*ControlCommand_DenyDomain
	//	*ControlCommand_RemoveDomain
	Command       isControlCommand_Command `protobuf_oneof:"command"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControlCommand) Reset() {
	*x = ControlCommand{}
	mi := &file_v1_control_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControlCommand) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControlCommand) ProtoMessage() {}

func (x *ControlCommand) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControlCommand.ProtoReflect.Descriptor instead.
func (*ControlCommand) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{7}
}

func (x *ControlCommand) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ControlCommand) GetCommand() isControlCommand_Command {
	if x != nil {
		return x.Command
	}
	return nil
}

func (x *ControlCommand) GetSyncAck() *SyncAck {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_SyncAck); ok {
			return x.SyncAck
		}
	}
	return nil
}

func (x *ControlCommand) GetSetMode() *SetMode {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_SetMode); ok {
			return x.SetMode
		}
	}
	return nil
}

func (x *ControlCommand) GetAllowCidr() *CIDREntry {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_AllowCidr); ok {
			return x.AllowCidr
		}
	}
	return nil
}

func (x *ControlCommand) GetDenyCidr() *CIDREntry {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_DenyCidr); ok {
			return x.DenyCidr
		}
	}
	return nil
}

func (x *ControlCommand) GetRemoveCidr() string {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_RemoveCidr); ok {
			return x.RemoveCidr
		}
	}
	return ""
}

func (x *ControlCommand) GetBulkUpdate() *BulkUpdate {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_BulkUpdate); ok {
			return x.BulkUpdate
		}
	}
	return nil
}

func (x *ControlCommand) GetSetDnsMode() *SetDnsMode {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_SetDnsMode); ok {
			return x.SetDnsMode
		}
	}
	return nil
}

func (x *ControlCommand) GetAllowDomain() *DomainEntry {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_AllowDomain); ok {
			return x.AllowDomain
		}
	}
	return nil
}

func (x *ControlCommand) GetDenyDomain() *DomainEntry {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_DenyDomain); ok {
			return x.DenyDomain
		}
	}
	return nil
}

func (x *ControlCommand) GetRemoveDomain() string {
	if x != nil {
		if x, ok := x.Command.(*ControlCommand_RemoveDomain); ok {
			return x.RemoveDomain
		}
	}
	return ""
}

type isControlCommand_Command interface {
	isControlCommand_Command()
}

type ControlCommand_SyncAck struct {
	// Acknowledge sync (sent after receiving SyncRequest)
	SyncAck *SyncAck `protobuf:"bytes,2,opt,name=sync_ack,json=syncAck,proto3,oneof"`
}

type ControlCommand_SetMode struct {
	// Change the IP filter policy mode
	SetMode *SetMode `protobuf:"bytes,3,opt,name=set_mode,json=setMode,proto3,oneof"`
}

type ControlCommand_AllowCidr struct {
	// Add a CIDR to the allowlist
	AllowCidr *CIDREntry `protobuf:"bytes,4,opt,name=allow_cidr,json=allowCidr,proto3,oneof"`
}

type ControlCommand_DenyCidr struct {
	// Add a CIDR to the denylist
	DenyCidr *CIDREntry `protobuf:"bytes,5,opt,name=deny_cidr,json=denyCidr,proto3,oneof"`
}

type ControlCommand_RemoveCidr struct {
	// Remove a CIDR from allow/deny lists
	RemoveCidr string `protobuf:"bytes,6,opt,name=remove_cidr,json=removeCidr,proto3,oneof"`
}

type ControlCommand_BulkUpdate struct {
	// Bulk update - set complete state for an attachment
	BulkUpdate *BulkUpdate `protobuf:"bytes,7,opt,name=bulk_update,json=bulkUpdate,proto3,oneof"`
}

type ControlCommand_SetDnsMode struct {
	// Change the DNS mode
	SetDnsMode *SetDnsMode `protobuf:"bytes,8,opt,name=set_dns_mode,json=setDnsMode,proto3,oneof"`
}

type ControlCommand_AllowDomain struct {
	// Add a domain to the DNS allowlist
	AllowDomain *DomainEntry `protobuf:"bytes,9,opt,name=allow_domain,json=allowDomain,proto3,oneof"`
}

type ControlCommand_DenyDomain struct {
	// Add a domain to the DNS denylist
	DenyDomain *DomainEntry `protobuf:"bytes,10,opt,name=deny_domain,json=denyDomain,proto3,oneof"`
}

type ControlCommand_RemoveDomain struct {
	// Remove a domain from DNS allow/deny lists
	RemoveDomain string `protobuf:"bytes,11,opt,name=remove_domain,json=removeDomain,proto3,oneof"`
}

func (*ControlCommand_SyncAck) isControlCommand_Command() {}

func (*ControlCommand_SetMode) isControlCommand_Command() {}

func (*ControlCommand_AllowCidr) isControlCommand_Command() {}

func (*ControlCommand_DenyCidr) isControlCommand_Command() {}

func (*ControlCommand_RemoveCidr) isControlCommand_Command() {}

func (*ControlCommand_BulkUpdate) isControlCommand_Command() {}

func (*ControlCommand_SetDnsMode) isControlCommand_Command() {}

func (*ControlCommand_AllowDomain) isControlCommand_Command() {}

func (*ControlCommand_DenyDomain) isControlCommand_Command() {}

func (*ControlCommand_RemoveDomain) isControlCommand_Command() {}

// SyncAck acknowledges that the control plane has processed the SyncRequest.
type SyncAck struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SyncAck) Reset() {
	*x = SyncAck{}
	mi := &file_v1_control_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SyncAck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SyncAck) ProtoMessage() {}

func (x *SyncAck) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SyncAck.ProtoReflect.Descriptor instead.
func (*SyncAck) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{8}
}

// SetMode changes the policy mode for an attachment.
type SetMode struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Mode          PolicyMode             `protobuf:"varint,1,opt,name=mode,proto3,enum=netfence.v1.PolicyMode" json:"mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetMode) Reset() {
	*x = SetMode{}
	mi := &file_v1_control_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetMode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetMode) ProtoMessage() {}

func (x *SetMode) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetMode.ProtoReflect.Descriptor instead.
func (*SetMode) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{9}
}

func (x *SetMode) GetMode() PolicyMode {
	if x != nil {
		return x.Mode
	}
	return PolicyMode_POLICY_MODE_UNSPECIFIED
}

// BulkUpdate sets the complete state for an attachment.
// Clears existing rules and replaces with the provided state.
type BulkUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IP filter policy mode
	Mode PolicyMode `protobuf:"varint,1,opt,name=mode,proto3,enum=netfence.v1.PolicyMode" json:"mode,omitempty"`
	// CIDRs to allow
	AllowCidrs []*CIDREntry `protobuf:"bytes,2,rep,name=allow_cidrs,json=allowCidrs,proto3" json:"allow_cidrs,omitempty"`
	// CIDRs to deny
	DenyCidrs []*CIDREntry `protobuf:"bytes,3,rep,name=deny_cidrs,json=denyCidrs,proto3" json:"deny_cidrs,omitempty"`
	// DNS configuration
	Dns           *DnsConfig `protobuf:"bytes,4,opt,name=dns,proto3" json:"dns,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BulkUpdate) Reset() {
	*x = BulkUpdate{}
	mi := &file_v1_control_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BulkUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BulkUpdate) ProtoMessage() {}

func (x *BulkUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BulkUpdate.ProtoReflect.Descriptor instead.
func (*BulkUpdate) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{10}
}

func (x *BulkUpdate) GetMode() PolicyMode {
	if x != nil {
		return x.Mode
	}
	return PolicyMode_POLICY_MODE_UNSPECIFIED
}

func (x *BulkUpdate) GetAllowCidrs() []*CIDREntry {
	if x != nil {
		return x.AllowCidrs
	}
	return nil
}

func (x *BulkUpdate) GetDenyCidrs() []*CIDREntry {
	if x != nil {
		return x.DenyCidrs
	}
	return nil
}

func (x *BulkUpdate) GetDns() *DnsConfig {
	if x != nil {
		return x.Dns
	}
	return nil
}

// DnsConfig contains the complete DNS filtering configuration.
type DnsConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// DNS filtering mode
	Mode DnsMode `protobuf:"varint,1,opt,name=mode,proto3,enum=netfence.v1.DnsMode" json:"mode,omitempty"`
	// Domains to allow (when mode is ALLOWLIST or to override in DENYLIST)
	AllowDomains []*DomainEntry `protobuf:"bytes,2,rep,name=allow_domains,json=allowDomains,proto3" json:"allow_domains,omitempty"`
	// Domains to deny (when mode is DENYLIST or to override in ALLOWLIST)
	DenyDomains []*DomainEntry `protobuf:"bytes,3,rep,name=deny_domains,json=denyDomains,proto3" json:"deny_domains,omitempty"`
	// Upstream DNS servers to use for resolution (optional, uses system default
	// if empty)
	UpstreamServers []string `protobuf:"bytes,4,rep,name=upstream_servers,json=upstreamServers,proto3" json:"upstream_servers,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DnsConfig) Reset() {
	*x = DnsConfig{}
	mi := &file_v1_control_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DnsConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DnsConfig) ProtoMessage() {}

func (x *DnsConfig) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DnsConfig.ProtoReflect.Descriptor instead.
func (*DnsConfig) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{11}
}

func (x *DnsConfig) GetMode() DnsMode {
	if x != nil {
		return x.Mode
	}
	return DnsMode_DNS_MODE_UNSPECIFIED
}

func (x *DnsConfig) GetAllowDomains() []*DomainEntry {
	if x != nil {
		return x.AllowDomains
	}
	return nil
}

func (x *DnsConfig) GetDenyDomains() []*DomainEntry {
	if x != nil {
		return x.DenyDomains
	}
	return nil
}

func (x *DnsConfig) GetUpstreamServers() []string {
	if x != nil {
		return x.UpstreamServers
	}
	return nil
}

// CIDREntry represents a CIDR with optional TTL.
type CIDREntry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Cidr          string                 `protobuf:"bytes,1,opt,name=cidr,proto3" json:"cidr,omitempty"`
	Ttl           *durationpb.Duration   `protobuf:"bytes,2,opt,name=ttl,proto3" json:"ttl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CIDREntry) Reset() {
	*x = CIDREntry{}
	mi := &file_v1_control_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CIDREntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CIDREntry) ProtoMessage() {}

func (x *CIDREntry) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CIDREntry.ProtoReflect.Descriptor instead.
func (*CIDREntry) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{12}
}

func (x *CIDREntry) GetCidr() string {
	if x != nil {
		return x.Cidr
	}
	return ""
}

func (x *CIDREntry) GetTtl() *durationpb.Duration {
	if x != nil {
		return x.Ttl
	}
	return nil
}

// DomainEntry represents a domain with optional settings.
type DomainEntry struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The domain (e.g., "example.com")
	Domain string `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty"`
	// Whether to include subdomains (e.g., "*.example.com")
	IncludeSubdomains bool `protobuf:"varint,2,opt,name=include_subdomains,json=includeSubdomains,proto3" json:"include_subdomains,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *DomainEntry) Reset() {
	*x = DomainEntry{}
	mi := &file_v1_control_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DomainEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DomainEntry) ProtoMessage() {}

func (x *DomainEntry) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DomainEntry.ProtoReflect.Descriptor instead.
func (*DomainEntry) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{13}
}

func (x *DomainEntry) GetDomain() string {
	if x != nil {
		return x.Domain
	}
	return ""
}

func (x *DomainEntry) GetIncludeSubdomains() bool {
	if x != nil {
		return x.IncludeSubdomains
	}
	return false
}

// SetDnsMode changes the DNS filtering mode.
type SetDnsMode struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Mode          DnsMode                `protobuf:"varint,1,opt,name=mode,proto3,enum=netfence.v1.DnsMode" json:"mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetDnsMode) Reset() {
	*x = SetDnsMode{}
	mi := &file_v1_control_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetDnsMode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetDnsMode) ProtoMessage() {}

func (x *SetDnsMode) ProtoReflect() protoreflect.Message {
	mi := &file_v1_control_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetDnsMode.ProtoReflect.Descriptor instead.
func (*SetDnsMode) Descriptor() ([]byte, []int) {
	return file_v1_control_proto_rawDescGZIP(), []int{14}
}

func (x *SetDnsMode) GetMode() DnsMode {
	if x != nil {
		return x.Mode
	}
	return DnsMode_DNS_MODE_UNSPECIFIED
}

var File_v1_control_proto protoreflect.FileDescriptor

const file_v1_control_proto_rawDesc = "" +
	"\n" +
	"\x10v1/control.proto\x12\vnetfence.v1\x1a\x1egoogle/protobuf/duration.proto\x1a\x0ev1/types.proto\"\xfa\x01\n" +
	"\vDaemonEvent\x12.\n" +
	"\x04sync\x18\x01 \x01(\v2\x18.netfence.v1.SyncRequestH\x00R\x04sync\x129\n" +
	"\n" +
	"subscribed\x18\x02 \x01(\v2\x17.netfence.v1.SubscribedH\x00R\n" +
	"subscribed\x12?\n" +
	"\funsubscribed\x18\x03 \x01(\v2\x19.netfence.v1.UnsubscribedH\x00R\funsubscribed\x126\n" +
	"\theartbeat\x18\x04 \x01(\v2\x16.netfence.v1.HeartbeatH\x00R\theartbeatB\a\n" +
	"\x05event\"\x81\x01\n" +
	"\vSyncRequest\x12\x1b\n" +
	"\tdaemon_id\x18\x01 \x01(\tR\bdaemonId\x12\x1a\n" +
	"\bhostname\x18\x02 \x01(\tR\bhostname\x129\n" +
	"\vattachments\x18\x03 \x03(\v2\x17.netfence.v1.AttachmentR\vattachments\"\xc3\x02\n" +
	"\n" +
	"Attachment\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x16\n" +
	"\x06target\x18\x02 \x01(\tR\x06target\x12/\n" +
	"\x04type\x18\x03 \x01(\x0e2\x1b.netfence.v1.AttachmentTypeR\x04type\x12+\n" +
	"\x04mode\x18\x04 \x01(\x0e2\x17.netfence.v1.PolicyModeR\x04mode\x12/\n" +
	"\bdns_mode\x18\x05 \x01(\x0e2\x14.netfence.v1.DnsModeR\adnsMode\x12A\n" +
	"\bmetadata\x18\x06 \x03(\v2%.netfence.v1.Attachment.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xe4\x02\n" +
	"\n" +
	"Subscribed\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x16\n" +
	"\x06target\x18\x02 \x01(\tR\x06target\x12/\n" +
	"\x04type\x18\x03 \x01(\x0e2\x1b.netfence.v1.AttachmentTypeR\x04type\x12+\n" +
	"\x04mode\x18\x04 \x01(\x0e2\x17.netfence.v1.PolicyModeR\x04mode\x12/\n" +
	"\bdns_mode\x18\x05 \x01(\x0e2\x14.netfence.v1.DnsModeR\adnsMode\x12\x1f\n" +
	"\vdns_address\x18\x06 \x01(\tR\n" +
	"dnsAddress\x12A\n" +
	"\bmetadata\x18\a \x03(\v2%.netfence.v1.Subscribed.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"l\n" +
	"\fUnsubscribed\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x126\n" +
	"\x06reason\x18\x02 \x01(\x0e2\x1e.netfence.v1.UnsubscribeReasonR\x06reason\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\"?\n" +
	"\tHeartbeat\x122\n" +
	"\x05stats\x18\x01 \x03(\v2\x1c.netfence.v1.AttachmentStatsR\x05stats\"\xd3\x01\n" +
	"\x0fAttachmentStats\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12'\n" +
	"\x0fpackets_allowed\x18\x02 \x01(\x04R\x0epacketsAllowed\x12'\n" +
	"\x0fpackets_blocked\x18\x03 \x01(\x04R\x0epacketsBlocked\x12.\n" +
	"\x13dns_queries_allowed\x18\x04 \x01(\x04R\x11dnsQueriesAllowed\x12.\n" +
	"\x13dns_queries_blocked\x18\x05 \x01(\x04R\x11dnsQueriesBlocked\"\xc0\x04\n" +
	"\x0eControlCommand\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x121\n" +
	"\bsync_ack\x18\x02 \x01(\v2\x14.netfence.v1.SyncAckH\x00R\asyncAck\x121\n" +
	"\bset_mode\x18\x03 \x01(\v2\x14.netfence.v1.SetModeH\x00R\asetMode\x127\n" +
	"\n" +
	"allow_cidr\x18\x04 \x01(\v2\x16.netfence.v1.CIDREntryH\x00R\tallowCidr\x125\n" +
	"\tdeny_cidr\x18\x05 \x01(\v2\x16.netfence.v1.CIDREntryH\x00R\bdenyCidr\x12!\n" +
	"\vremove_cidr\x18\x06 \x01(\tH\x00R\n" +
	"removeCidr\x12:\n" +
	"\vbulk_update\x18\a \x01(\v2\x17.netfence.v1.BulkUpdateH\x00R\n" +
	"bulkUpdate\x12;\n" +
	"\fset_dns_mode\x18\b \x01(\v2\x17.netfence.v1.SetDnsModeH\x00R\n" +
	"setDnsMode\x12=\n" +
	"\fallow_domain\x18\t \x01(\v2\x18.netfence.v1.DomainEntryH\x00R\vallowDomain\x12;\n" +
	"\vdeny_domain\x18\n" +
	" \x01(\v2\x18.netfence.v1.DomainEntryH\x00R\n" +
	"denyDomain\x12%\n" +
	"\rremove_domain\x18\v \x01(\tH\x00R\fremoveDomainB\t\n" +
	"\acommand\"\t\n" +
	"\aSyncAck\"6\n" +
	"\aSetMode\x12+\n" +
	"\x04mode\x18\x01 \x01(\x0e2\x17.netfence.v1.PolicyModeR\x04mode\"\xd3\x01\n" +
	"\n" +
	"BulkUpdate\x12+\n" +
	"\x04mode\x18\x01 \x01(\x0e2\x17.netfence.v1.PolicyModeR\x04mode\x127\n" +
	"\vallow_cidrs\x18\x02 \x03(\v2\x16.netfence.v1.CIDREntryR\n" +
	"allowCidrs\x125\n" +
	"\n" +
	"deny_cidrs\x18\x03 \x03(\v2\x16.netfence.v1.CIDREntryR\tdenyCidrs\x12(\n" +
	"\x03dns\x18\x04 \x01(\v2\x16.netfence.v1.DnsConfigR\x03dns\"\xdc\x01\n" +
	"\tDnsConfig\x12(\n" +
	"\x04mode\x18\x01 \x01(\x0e2\x14.netfence.v1.DnsModeR\x04mode\x12=\n" +
	"\rallow_domains\x18\x02 \x03(\v2\x18.netfence.v1.DomainEntryR\fallowDomains\x12;\n" +
	"\fdeny_domains\x18\x03 \x03(\v2\x18.netfence.v1.DomainEntryR\vdenyDomains\x12)\n" +
	"\x10upstream_servers\x18\x04 \x03(\tR\x0fupstreamServers\"L\n" +
	"\tCIDREntry\x12\x12\n" +
	"\x04cidr\x18\x01 \x01(\tR\x04cidr\x12+\n" +
	"\x03ttl\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\x03ttl\"T\n" +
	"\vDomainEntry\x12\x16\n" +
	"\x06domain\x18\x01 \x01(\tR\x06domain\x12-\n" +
	"\x12include_subdomains\x18\x02 \x01(\bR\x11includeSubdomains\"6\n" +
	"\n" +
	"SetDnsMode\x12(\n" +
	"\x04mode\x18\x01 \x01(\x0e2\x14.netfence.v1.DnsModeR\x04mode*\x96\x01\n" +
	"\x11UnsubscribeReason\x12\"\n" +
	"\x1eUNSUBSCRIBE_REASON_UNSPECIFIED\x10\x00\x12\x1e\n" +
	"\x1aUNSUBSCRIBE_REASON_REMOVED\x10\x01\x12\x1f\n" +
	"\x1bUNSUBSCRIBE_REASON_DETACHED\x10\x02\x12\x1c\n" +
	"\x18UNSUBSCRIBE_REASON_ERROR\x10\x032T\n" +
	"\fControlPlane\x12D\n" +
	"\aConnect\x12\x18.netfence.v1.DaemonEvent\x1a\x1b.netfence.v1.ControlCommand(\x010\x01B1Z/github.com/danthegoodman1/netfence/api/v1;apiv1b\x06proto3"

var (
	file_v1_control_proto_rawDescOnce sync.Once
	file_v1_control_proto_rawDescData []byte
)

func file_v1_control_proto_rawDescGZIP() []byte {
	file_v1_control_proto_rawDescOnce.Do(func() {
		file_v1_control_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_v1_control_proto_rawDesc), len(file_v1_control_proto_rawDesc)))
	})
	return file_v1_control_proto_rawDescData
}

var file_v1_control_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_v1_control_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_v1_control_proto_goTypes = []any{
	(UnsubscribeReason)(0),      // 0: netfence.v1.UnsubscribeReason
	(*DaemonEvent)(nil),         // 1: netfence.v1.DaemonEvent
	(*SyncRequest)(nil),         // 2: netfence.v1.SyncRequest
	(*Attachment)(nil),          // 3: netfence.v1.Attachment
	(*Subscribed)(nil),          // 4: netfence.v1.Subscribed
	(*Unsubscribed)(nil),        // 5: netfence.v1.Unsubscribed
	(*Heartbeat)(nil),           // 6: netfence.v1.Heartbeat
	(*AttachmentStats)(nil),     // 7: netfence.v1.AttachmentStats
	(*ControlCommand)(nil),      // 8: netfence.v1.ControlCommand
	(*SyncAck)(nil),             // 9: netfence.v1.SyncAck
	(*SetMode)(nil),             // 10: netfence.v1.SetMode
	(*BulkUpdate)(nil),          // 11: netfence.v1.BulkUpdate
	(*DnsConfig)(nil),           // 12: netfence.v1.DnsConfig
	(*CIDREntry)(nil),           // 13: netfence.v1.CIDREntry
	(*DomainEntry)(nil),         // 14: netfence.v1.DomainEntry
	(*SetDnsMode)(nil),          // 15: netfence.v1.SetDnsMode
	nil,                         // 16: netfence.v1.Attachment.MetadataEntry
	nil,                         // 17: netfence.v1.Subscribed.MetadataEntry
	(AttachmentType)(0),         // 18: netfence.v1.AttachmentType
	(PolicyMode)(0),             // 19: netfence.v1.PolicyMode
	(DnsMode)(0),                // 20: netfence.v1.DnsMode
	(*durationpb.Duration)(nil), // 21: google.protobuf.Duration
}
var file_v1_control_proto_depIdxs = []int32{
	2,  // 0: netfence.v1.DaemonEvent.sync:type_name -> netfence.v1.SyncRequest
	4,  // 1: netfence.v1.DaemonEvent.subscribed:type_name -> netfence.v1.Subscribed
	5,  // 2: netfence.v1.DaemonEvent.unsubscribed:type_name -> netfence.v1.Unsubscribed
	6,  // 3: netfence.v1.DaemonEvent.heartbeat:type_name -> netfence.v1.Heartbeat
	3,  // 4: netfence.v1.SyncRequest.attachments:type_name -> netfence.v1.Attachment
	18, // 5: netfence.v1.Attachment.type:type_name -> netfence.v1.AttachmentType
	19, // 6: netfence.v1.Attachment.mode:type_name -> netfence.v1.PolicyMode
	20, // 7: netfence.v1.Attachment.dns_mode:type_name -> netfence.v1.DnsMode
	16, // 8: netfence.v1.Attachment.metadata:type_name -> netfence.v1.Attachment.MetadataEntry
	18, // 9: netfence.v1.Subscribed.type:type_name -> netfence.v1.AttachmentType
	19, // 10: netfence.v1.Subscribed.mode:type_name -> netfence.v1.PolicyMode
	20, // 11: netfence.v1.Subscribed.dns_mode:type_name -> netfence.v1.DnsMode
	17, // 12: netfence.v1.Subscribed.metadata:type_name -> netfence.v1.Subscribed.MetadataEntry
	0,  // 13: netfence.v1.Unsubscribed.reason:type_name -> netfence.v1.UnsubscribeReason
	7,  // 14: netfence.v1.Heartbeat.stats:type_name -> netfence.v1.AttachmentStats
	9,  // 15: netfence.v1.ControlCommand.sync_ack:type_name -> netfence.v1.SyncAck
	10, // 16: netfence.v1.ControlCommand.set_mode:type_name -> netfence.v1.SetMode
	13, // 17: netfence.v1.ControlCommand.allow_cidr:type_name -> netfence.v1.CIDREntry
	13, // 18: netfence.v1.ControlCommand.deny_cidr:type_name -> netfence.v1.CIDREntry
	11, // 19: netfence.v1.ControlCommand.bulk_update:type_name -> netfence.v1.BulkUpdate
	15, // 20: netfence.v1.ControlCommand.set_dns_mode:type_name -> netfence.v1.SetDnsMode
	14, // 21: netfence.v1.ControlCommand.allow_domain:type_name -> netfence.v1.DomainEntry
	14, // 22: netfence.v1.ControlCommand.deny_domain:type_name -> netfence.v1.DomainEntry
	19, // 23: netfence.v1.SetMode.mode:type_name -> netfence.v1.PolicyMode
	19, // 24: netfence.v1.BulkUpdate.mode:type_name -> netfence.v1.PolicyMode
	13, // 25: netfence.v1.BulkUpdate.allow_cidrs:type_name -> netfence.v1.CIDREntry
	13, // 26: netfence.v1.BulkUpdate.deny_cidrs:type_name -> netfence.v1.CIDREntry
	12, // 27: netfence.v1.BulkUpdate.dns:type_name -> netfence.v1.DnsConfig
	20, // 28: netfence.v1.DnsConfig.mode:type_name -> netfence.v1.DnsMode
	14, // 29: netfence.v1.DnsConfig.allow_domains:type_name -> netfence.v1.DomainEntry
	14, // 30: netfence.v1.DnsConfig.deny_domains:type_name -> netfence.v1.DomainEntry
	21, // 31: netfence.v1.CIDREntry.ttl:type_name -> google.protobuf.Duration
	20, // 32: netfence.v1.SetDnsMode.mode:type_name -> netfence.v1.DnsMode
	1,  // 33: netfence.v1.ControlPlane.Connect:input_type -> netfence.v1.DaemonEvent
	8,  // 34: netfence.v1.ControlPlane.Connect:output_type -> netfence.v1.ControlCommand
	34, // [34:35] is the sub-list for method output_type
	33, // [33:34] is the sub-list for method input_type
	33, // [33:33] is the sub-list for extension type_name
	33, // [33:33] is the sub-list for extension extendee
	0,  // [0:33] is the sub-list for field type_name
}

func init() { file_v1_control_proto_init() }
func file_v1_control_proto_init() {
	if File_v1_control_proto != nil {
		return
	}
	file_v1_types_proto_init()
	file_v1_control_proto_msgTypes[0].OneofWrappers = []any{
		(*DaemonEvent_Sync)(nil),
		(*DaemonEvent_Subscribed)(nil),
		(*DaemonEvent_Unsubscribed)(nil),
		(*DaemonEvent_Heartbeat)(nil),
	}
	file_v1_control_proto_msgTypes[7].OneofWrappers = []any{
		(*ControlCommand_SyncAck)(nil),
		(*ControlCommand_SetMode)(nil),
		(*ControlCommand_AllowCidr)(nil),
		(*ControlCommand_DenyCidr)(nil),
		(*ControlCommand_RemoveCidr)(nil),
		(*ControlCommand_BulkUpdate)(nil),
		(*ControlCommand_SetDnsMode)(nil),
		(*ControlCommand_AllowDomain)(nil),
		(*ControlCommand_DenyDomain)(nil),
		(*ControlCommand_RemoveDomain)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_v1_control_proto_rawDesc), len(file_v1_control_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_v1_control_proto_goTypes,
		DependencyIndexes: file_v1_control_proto_depIdxs,
		EnumInfos:         file_v1_control_proto_enumTypes,
		MessageInfos:      file_v1_control_proto_msgTypes,
	}.Build()
	File_v1_control_proto = out.File
	file_v1_control_proto_goTypes = nil
	file_v1_control_proto_depIdxs = nil
}
