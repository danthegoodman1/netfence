// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: v1/daemon.proto

package apiv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ConnectionState represents the control plane connection status.
type ConnectionState int32

const (
	ConnectionState_CONNECTION_STATE_UNSPECIFIED  ConnectionState = 0
	ConnectionState_CONNECTION_STATE_DISCONNECTED ConnectionState = 1
	ConnectionState_CONNECTION_STATE_CONNECTING   ConnectionState = 2
	ConnectionState_CONNECTION_STATE_CONNECTED    ConnectionState = 3
)

// Enum value maps for ConnectionState.
var (
	ConnectionState_name = map[int32]string{
		0: "CONNECTION_STATE_UNSPECIFIED",
		1: "CONNECTION_STATE_DISCONNECTED",
		2: "CONNECTION_STATE_CONNECTING",
		3: "CONNECTION_STATE_CONNECTED",
	}
	ConnectionState_value = map[string]int32{
		"CONNECTION_STATE_UNSPECIFIED":  0,
		"CONNECTION_STATE_DISCONNECTED": 1,
		"CONNECTION_STATE_CONNECTING":   2,
		"CONNECTION_STATE_CONNECTED":    3,
	}
)

func (x ConnectionState) Enum() *ConnectionState {
	p := new(ConnectionState)
	*p = x
	return p
}

func (x ConnectionState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ConnectionState) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_daemon_proto_enumTypes[0].Descriptor()
}

func (ConnectionState) Type() protoreflect.EnumType {
	return &file_v1_daemon_proto_enumTypes[0]
}

func (x ConnectionState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ConnectionState.Descriptor instead.
func (ConnectionState) EnumDescriptor() ([]byte, []int) {
	return file_v1_daemon_proto_rawDescGZIP(), []int{0}
}

// AttachRequest specifies what to attach the eBPF filter to.
type AttachRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Target:
	//
	//	*AttachRequest_InterfaceName
	//	*AttachRequest_CgroupPath
	Target isAttachRequest_Target `protobuf_oneof:"target"`
	// Initial policy mode (defaults to DISABLED if not specified)
	Mode PolicyMode `protobuf:"varint,3,opt,name=mode,proto3,enum=superebpf.v1.PolicyMode" json:"mode,omitempty"`
	// User-defined metadata (VM ID, tenant, container ID, etc.)
	// This is passed to the control plane with the subscription.
	Metadata      map[string]string `protobuf:"bytes,4,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttachRequest) Reset() {
	*x = AttachRequest{}
	mi := &file_v1_daemon_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttachRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttachRequest) ProtoMessage() {}

func (x *AttachRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_daemon_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttachRequest.ProtoReflect.Descriptor instead.
func (*AttachRequest) Descriptor() ([]byte, []int) {
	return file_v1_daemon_proto_rawDescGZIP(), []int{0}
}

func (x *AttachRequest) GetTarget() isAttachRequest_Target {
	if x != nil {
		return x.Target
	}
	return nil
}

func (x *AttachRequest) GetInterfaceName() string {
	if x != nil {
		if x, ok := x.Target.(*AttachRequest_InterfaceName); ok {
			return x.InterfaceName
		}
	}
	return ""
}

func (x *AttachRequest) GetCgroupPath() string {
	if x != nil {
		if x, ok := x.Target.(*AttachRequest_CgroupPath); ok {
			return x.CgroupPath
		}
	}
	return ""
}

func (x *AttachRequest) GetMode() PolicyMode {
	if x != nil {
		return x.Mode
	}
	return PolicyMode_POLICY_MODE_UNSPECIFIED
}

func (x *AttachRequest) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type isAttachRequest_Target interface {
	isAttachRequest_Target()
}

type AttachRequest_InterfaceName struct {
	// Network interface name for TC attachment (e.g., "eth0", "veth123")
	InterfaceName string `protobuf:"bytes,1,opt,name=interface_name,json=interfaceName,proto3,oneof"`
}

type AttachRequest_CgroupPath struct {
	// Cgroup path for cgroup attachment (e.g., "/sys/fs/cgroup/user.slice/...")
	CgroupPath string `protobuf:"bytes,2,opt,name=cgroup_path,json=cgroupPath,proto3,oneof"`
}

func (*AttachRequest_InterfaceName) isAttachRequest_Target() {}

func (*AttachRequest_CgroupPath) isAttachRequest_Target() {}

// AttachResponse confirms attachment.
type AttachResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for this attachment (use this for detach)
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// DNS server address for this attachment (e.g., "127.0.0.1:5353")
	// Configure the container/VM to use this as its DNS resolver
	DnsAddress    string `protobuf:"bytes,2,opt,name=dns_address,json=dnsAddress,proto3" json:"dns_address,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttachResponse) Reset() {
	*x = AttachResponse{}
	mi := &file_v1_daemon_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttachResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttachResponse) ProtoMessage() {}

func (x *AttachResponse) ProtoReflect() protoreflect.Message {
	mi := &file_v1_daemon_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttachResponse.ProtoReflect.Descriptor instead.
func (*AttachResponse) Descriptor() ([]byte, []int) {
	return file_v1_daemon_proto_rawDescGZIP(), []int{1}
}

func (x *AttachResponse) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *AttachResponse) GetDnsAddress() string {
	if x != nil {
		return x.DnsAddress
	}
	return ""
}

// DetachRequest specifies which attachment to remove.
type DetachRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Attachment ID (from AttachResponse)
	Id            string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DetachRequest) Reset() {
	*x = DetachRequest{}
	mi := &file_v1_daemon_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DetachRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DetachRequest) ProtoMessage() {}

func (x *DetachRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_daemon_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DetachRequest.ProtoReflect.Descriptor instead.
func (*DetachRequest) Descriptor() ([]byte, []int) {
	return file_v1_daemon_proto_rawDescGZIP(), []int{2}
}

func (x *DetachRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

// ListResponse contains all active attachments.
type ListResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Attachments   []*AttachmentInfo      `protobuf:"bytes,1,rep,name=attachments,proto3" json:"attachments,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListResponse) Reset() {
	*x = ListResponse{}
	mi := &file_v1_daemon_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListResponse) ProtoMessage() {}

func (x *ListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_v1_daemon_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListResponse.ProtoReflect.Descriptor instead.
func (*ListResponse) Descriptor() ([]byte, []int) {
	return file_v1_daemon_proto_rawDescGZIP(), []int{3}
}

func (x *ListResponse) GetAttachments() []*AttachmentInfo {
	if x != nil {
		return x.Attachments
	}
	return nil
}

// AttachmentInfo contains details about an active attachment.
type AttachmentInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Id    string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The target (interface name or cgroup path)
	Target string `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	// Type of attachment
	Type AttachmentType `protobuf:"varint,3,opt,name=type,proto3,enum=superebpf.v1.AttachmentType" json:"type,omitempty"`
	// IP filter policy mode
	Mode PolicyMode `protobuf:"varint,4,opt,name=mode,proto3,enum=superebpf.v1.PolicyMode" json:"mode,omitempty"`
	// DNS filtering mode
	DnsMode DnsMode `protobuf:"varint,5,opt,name=dns_mode,json=dnsMode,proto3,enum=superebpf.v1.DnsMode" json:"dns_mode,omitempty"`
	// DNS server address for this attachment
	DnsAddress        string            `protobuf:"bytes,6,opt,name=dns_address,json=dnsAddress,proto3" json:"dns_address,omitempty"`
	Metadata          map[string]string `protobuf:"bytes,7,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	PacketsAllowed    uint64            `protobuf:"varint,8,opt,name=packets_allowed,json=packetsAllowed,proto3" json:"packets_allowed,omitempty"`
	PacketsBlocked    uint64            `protobuf:"varint,9,opt,name=packets_blocked,json=packetsBlocked,proto3" json:"packets_blocked,omitempty"`
	DnsQueriesAllowed uint64            `protobuf:"varint,10,opt,name=dns_queries_allowed,json=dnsQueriesAllowed,proto3" json:"dns_queries_allowed,omitempty"`
	DnsQueriesBlocked uint64            `protobuf:"varint,11,opt,name=dns_queries_blocked,json=dnsQueriesBlocked,proto3" json:"dns_queries_blocked,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *AttachmentInfo) Reset() {
	*x = AttachmentInfo{}
	mi := &file_v1_daemon_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttachmentInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttachmentInfo) ProtoMessage() {}

func (x *AttachmentInfo) ProtoReflect() protoreflect.Message {
	mi := &file_v1_daemon_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttachmentInfo.ProtoReflect.Descriptor instead.
func (*AttachmentInfo) Descriptor() ([]byte, []int) {
	return file_v1_daemon_proto_rawDescGZIP(), []int{4}
}

func (x *AttachmentInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *AttachmentInfo) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *AttachmentInfo) GetType() AttachmentType {
	if x != nil {
		return x.Type
	}
	return AttachmentType_ATTACHMENT_TYPE_UNSPECIFIED
}

func (x *AttachmentInfo) GetMode() PolicyMode {
	if x != nil {
		return x.Mode
	}
	return PolicyMode_POLICY_MODE_UNSPECIFIED
}

func (x *AttachmentInfo) GetDnsMode() DnsMode {
	if x != nil {
		return x.DnsMode
	}
	return DnsMode_DNS_MODE_UNSPECIFIED
}

func (x *AttachmentInfo) GetDnsAddress() string {
	if x != nil {
		return x.DnsAddress
	}
	return ""
}

func (x *AttachmentInfo) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *AttachmentInfo) GetPacketsAllowed() uint64 {
	if x != nil {
		return x.PacketsAllowed
	}
	return 0
}

func (x *AttachmentInfo) GetPacketsBlocked() uint64 {
	if x != nil {
		return x.PacketsBlocked
	}
	return 0
}

func (x *AttachmentInfo) GetDnsQueriesAllowed() uint64 {
	if x != nil {
		return x.DnsQueriesAllowed
	}
	return 0
}

func (x *AttachmentInfo) GetDnsQueriesBlocked() uint64 {
	if x != nil {
		return x.DnsQueriesBlocked
	}
	return 0
}

// DaemonStatus contains the current state of the daemon.
type DaemonStatus struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Version  string                 `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	DaemonId string                 `protobuf:"bytes,2,opt,name=daemon_id,json=daemonId,proto3" json:"daemon_id,omitempty"`
	Hostname string                 `protobuf:"bytes,3,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Control plane connection state
	ControlPlaneState   ConnectionState `protobuf:"varint,4,opt,name=control_plane_state,json=controlPlaneState,proto3,enum=superebpf.v1.ConnectionState" json:"control_plane_state,omitempty"`
	ControlPlaneAddress string          `protobuf:"bytes,5,opt,name=control_plane_address,json=controlPlaneAddress,proto3" json:"control_plane_address,omitempty"`
	AttachmentCount     int32           `protobuf:"varint,6,opt,name=attachment_count,json=attachmentCount,proto3" json:"attachment_count,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *DaemonStatus) Reset() {
	*x = DaemonStatus{}
	mi := &file_v1_daemon_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DaemonStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DaemonStatus) ProtoMessage() {}

func (x *DaemonStatus) ProtoReflect() protoreflect.Message {
	mi := &file_v1_daemon_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DaemonStatus.ProtoReflect.Descriptor instead.
func (*DaemonStatus) Descriptor() ([]byte, []int) {
	return file_v1_daemon_proto_rawDescGZIP(), []int{5}
}

func (x *DaemonStatus) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *DaemonStatus) GetDaemonId() string {
	if x != nil {
		return x.DaemonId
	}
	return ""
}

func (x *DaemonStatus) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *DaemonStatus) GetControlPlaneState() ConnectionState {
	if x != nil {
		return x.ControlPlaneState
	}
	return ConnectionState_CONNECTION_STATE_UNSPECIFIED
}

func (x *DaemonStatus) GetControlPlaneAddress() string {
	if x != nil {
		return x.ControlPlaneAddress
	}
	return ""
}

func (x *DaemonStatus) GetAttachmentCount() int32 {
	if x != nil {
		return x.AttachmentCount
	}
	return 0
}

var File_v1_daemon_proto protoreflect.FileDescriptor

const file_v1_daemon_proto_rawDesc = "" +
	"\n" +
	"\x0fv1/daemon.proto\x12\fsuperebpf.v1\x1a\x1bgoogle/protobuf/empty.proto\x1a\x0ev1/types.proto\"\x97\x02\n" +
	"\rAttachRequest\x12'\n" +
	"\x0einterface_name\x18\x01 \x01(\tH\x00R\rinterfaceName\x12!\n" +
	"\vcgroup_path\x18\x02 \x01(\tH\x00R\n" +
	"cgroupPath\x12,\n" +
	"\x04mode\x18\x03 \x01(\x0e2\x18.superebpf.v1.PolicyModeR\x04mode\x12E\n" +
	"\bmetadata\x18\x04 \x03(\v2).superebpf.v1.AttachRequest.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\b\n" +
	"\x06target\"A\n" +
	"\x0eAttachResponse\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1f\n" +
	"\vdns_address\x18\x02 \x01(\tR\n" +
	"dnsAddress\"\x1f\n" +
	"\rDetachRequest\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"N\n" +
	"\fListResponse\x12>\n" +
	"\vattachments\x18\x01 \x03(\v2\x1c.superebpf.v1.AttachmentInfoR\vattachments\"\xa2\x04\n" +
	"\x0eAttachmentInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x16\n" +
	"\x06target\x18\x02 \x01(\tR\x06target\x120\n" +
	"\x04type\x18\x03 \x01(\x0e2\x1c.superebpf.v1.AttachmentTypeR\x04type\x12,\n" +
	"\x04mode\x18\x04 \x01(\x0e2\x18.superebpf.v1.PolicyModeR\x04mode\x120\n" +
	"\bdns_mode\x18\x05 \x01(\x0e2\x15.superebpf.v1.DnsModeR\adnsMode\x12\x1f\n" +
	"\vdns_address\x18\x06 \x01(\tR\n" +
	"dnsAddress\x12F\n" +
	"\bmetadata\x18\a \x03(\v2*.superebpf.v1.AttachmentInfo.MetadataEntryR\bmetadata\x12'\n" +
	"\x0fpackets_allowed\x18\b \x01(\x04R\x0epacketsAllowed\x12'\n" +
	"\x0fpackets_blocked\x18\t \x01(\x04R\x0epacketsBlocked\x12.\n" +
	"\x13dns_queries_allowed\x18\n" +
	" \x01(\x04R\x11dnsQueriesAllowed\x12.\n" +
	"\x13dns_queries_blocked\x18\v \x01(\x04R\x11dnsQueriesBlocked\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x8f\x02\n" +
	"\fDaemonStatus\x12\x18\n" +
	"\aversion\x18\x01 \x01(\tR\aversion\x12\x1b\n" +
	"\tdaemon_id\x18\x02 \x01(\tR\bdaemonId\x12\x1a\n" +
	"\bhostname\x18\x03 \x01(\tR\bhostname\x12M\n" +
	"\x13control_plane_state\x18\x04 \x01(\x0e2\x1d.superebpf.v1.ConnectionStateR\x11controlPlaneState\x122\n" +
	"\x15control_plane_address\x18\x05 \x01(\tR\x13controlPlaneAddress\x12)\n" +
	"\x10attachment_count\x18\x06 \x01(\x05R\x0fattachmentCount*\x97\x01\n" +
	"\x0fConnectionState\x12 \n" +
	"\x1cCONNECTION_STATE_UNSPECIFIED\x10\x00\x12!\n" +
	"\x1dCONNECTION_STATE_DISCONNECTED\x10\x01\x12\x1f\n" +
	"\x1bCONNECTION_STATE_CONNECTING\x10\x02\x12\x1e\n" +
	"\x1aCONNECTION_STATE_CONNECTED\x10\x032\x90\x02\n" +
	"\rDaemonService\x12C\n" +
	"\x06Attach\x12\x1b.superebpf.v1.AttachRequest\x1a\x1c.superebpf.v1.AttachResponse\x12=\n" +
	"\x06Detach\x12\x1b.superebpf.v1.DetachRequest\x1a\x16.google.protobuf.Empty\x12:\n" +
	"\x04List\x12\x16.google.protobuf.Empty\x1a\x1a.superebpf.v1.ListResponse\x12?\n" +
	"\tGetStatus\x12\x16.google.protobuf.Empty\x1a\x1a.superebpf.v1.DaemonStatusB2Z0github.com/danthegoodman1/superebpf/api/v1;apiv1b\x06proto3"

var (
	file_v1_daemon_proto_rawDescOnce sync.Once
	file_v1_daemon_proto_rawDescData []byte
)

func file_v1_daemon_proto_rawDescGZIP() []byte {
	file_v1_daemon_proto_rawDescOnce.Do(func() {
		file_v1_daemon_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_v1_daemon_proto_rawDesc), len(file_v1_daemon_proto_rawDesc)))
	})
	return file_v1_daemon_proto_rawDescData
}

var file_v1_daemon_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_v1_daemon_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_v1_daemon_proto_goTypes = []any{
	(ConnectionState)(0),   // 0: superebpf.v1.ConnectionState
	(*AttachRequest)(nil),  // 1: superebpf.v1.AttachRequest
	(*AttachResponse)(nil), // 2: superebpf.v1.AttachResponse
	(*DetachRequest)(nil),  // 3: superebpf.v1.DetachRequest
	(*ListResponse)(nil),   // 4: superebpf.v1.ListResponse
	(*AttachmentInfo)(nil), // 5: superebpf.v1.AttachmentInfo
	(*DaemonStatus)(nil),   // 6: superebpf.v1.DaemonStatus
	nil,                    // 7: superebpf.v1.AttachRequest.MetadataEntry
	nil,                    // 8: superebpf.v1.AttachmentInfo.MetadataEntry
	(PolicyMode)(0),        // 9: superebpf.v1.PolicyMode
	(AttachmentType)(0),    // 10: superebpf.v1.AttachmentType
	(DnsMode)(0),           // 11: superebpf.v1.DnsMode
	(*emptypb.Empty)(nil),  // 12: google.protobuf.Empty
}
var file_v1_daemon_proto_depIdxs = []int32{
	9,  // 0: superebpf.v1.AttachRequest.mode:type_name -> superebpf.v1.PolicyMode
	7,  // 1: superebpf.v1.AttachRequest.metadata:type_name -> superebpf.v1.AttachRequest.MetadataEntry
	5,  // 2: superebpf.v1.ListResponse.attachments:type_name -> superebpf.v1.AttachmentInfo
	10, // 3: superebpf.v1.AttachmentInfo.type:type_name -> superebpf.v1.AttachmentType
	9,  // 4: superebpf.v1.AttachmentInfo.mode:type_name -> superebpf.v1.PolicyMode
	11, // 5: superebpf.v1.AttachmentInfo.dns_mode:type_name -> superebpf.v1.DnsMode
	8,  // 6: superebpf.v1.AttachmentInfo.metadata:type_name -> superebpf.v1.AttachmentInfo.MetadataEntry
	0,  // 7: superebpf.v1.DaemonStatus.control_plane_state:type_name -> superebpf.v1.ConnectionState
	1,  // 8: superebpf.v1.DaemonService.Attach:input_type -> superebpf.v1.AttachRequest
	3,  // 9: superebpf.v1.DaemonService.Detach:input_type -> superebpf.v1.DetachRequest
	12, // 10: superebpf.v1.DaemonService.List:input_type -> google.protobuf.Empty
	12, // 11: superebpf.v1.DaemonService.GetStatus:input_type -> google.protobuf.Empty
	2,  // 12: superebpf.v1.DaemonService.Attach:output_type -> superebpf.v1.AttachResponse
	12, // 13: superebpf.v1.DaemonService.Detach:output_type -> google.protobuf.Empty
	4,  // 14: superebpf.v1.DaemonService.List:output_type -> superebpf.v1.ListResponse
	6,  // 15: superebpf.v1.DaemonService.GetStatus:output_type -> superebpf.v1.DaemonStatus
	12, // [12:16] is the sub-list for method output_type
	8,  // [8:12] is the sub-list for method input_type
	8,  // [8:8] is the sub-list for extension type_name
	8,  // [8:8] is the sub-list for extension extendee
	0,  // [0:8] is the sub-list for field type_name
}

func init() { file_v1_daemon_proto_init() }
func file_v1_daemon_proto_init() {
	if File_v1_daemon_proto != nil {
		return
	}
	file_v1_types_proto_init()
	file_v1_daemon_proto_msgTypes[0].OneofWrappers = []any{
		(*AttachRequest_InterfaceName)(nil),
		(*AttachRequest_CgroupPath)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_v1_daemon_proto_rawDesc), len(file_v1_daemon_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   8,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_v1_daemon_proto_goTypes,
		DependencyIndexes: file_v1_daemon_proto_depIdxs,
		EnumInfos:         file_v1_daemon_proto_enumTypes,
		MessageInfos:      file_v1_daemon_proto_msgTypes,
	}.Build()
	File_v1_daemon_proto = out.File
	file_v1_daemon_proto_goTypes = nil
	file_v1_daemon_proto_depIdxs = nil
}
